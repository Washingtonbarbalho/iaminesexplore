<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estratégia Mines IA Avançada</title>
    <!-- Configuração de PWA -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#5D5CDE">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            light: '#7676FF',
                            DEFAULT: '#5D5CDE',
                            dark: '#4545BC'
                        },
                        secondary: {
                            light: '#FF8C66',
                            DEFAULT: '#F97316',
                            dark: '#E05A00'
                        },
                        success: {
                            light: '#4ADE80',
                            DEFAULT: '#22C55E',
                            dark: '#16A34A'
                        },
                        danger: {
                            light: '#F87171',
                            DEFAULT: '#EF4444',
                            dark: '#DC2626'
                        },
                        warning: {
                            light: '#FBBF24',
                            DEFAULT: '#F59E0B',
                            dark: '#D97706'
                        },
                        info: {
                            light: '#38BDF8',
                            DEFAULT: '#0EA5E9',
                            dark: '#0284C7'
                        }
                    },
                    animation: {
                        'bounce-slow': 'bounce 3s infinite',
                        'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'spin-slow': 'spin 3s linear infinite',
                        'wiggle': 'wiggle 1s ease-in-out infinite',
                        'ping-slow': 'ping 2s cubic-bezier(0, 0, 0.2, 1) infinite',
                        'fade-in': 'fadeIn 0.5s ease-out',
                        'slide-up': 'slideUp 0.4s ease-out',
                        'slide-down': 'slideDown 0.4s ease-out',
                        'slide-in-right': 'slideInRight 0.4s ease-out',
                        'slide-in-left': 'slideInLeft 0.4s ease-out',
                        'scale-in': 'scaleIn 0.4s ease-out',
                        'scale-out': 'scaleOut 0.4s ease-out',
                        'float': 'float 3s ease-in-out infinite',
                        'shake': 'shake 0.5s ease-in-out',
                    },
                    keyframes: {
                        wiggle: {
                            '0%, 100%': { transform: 'rotate(-3deg)' },
                            '50%': { transform: 'rotate(3deg)' },
                        },
                        fadeIn: {
                            '0%': { opacity: 0 },
                            '100%': { opacity: 1 },
                        },
                        slideUp: {
                            '0%': { transform: 'translateY(20px)', opacity: 0 },
                            '100%': { transform: 'translateY(0)', opacity: 1 },
                        },
                        slideDown: {
                            '0%': { transform: 'translateY(-20px)', opacity: 0 },
                            '100%': { transform: 'translateY(0)', opacity: 1 },
                        },
                        slideInRight: {
                            '0%': { transform: 'translateX(50px)', opacity: 0 },
                            '100%': { transform: 'translateX(0)', opacity: 1 },
                        },
                        slideInLeft: {
                            '0%': { transform: 'translateX(-50px)', opacity: 0 },
                            '100%': { transform: 'translateX(0)', opacity: 1 },
                        },
                        scaleIn: {
                            '0%': { transform: 'scale(0.8)', opacity: 0 },
                            '100%': { transform: 'scale(1)', opacity: 1 },
                        },
                        scaleOut: {
                            '0%': { transform: 'scale(1.2)', opacity: 0 },
                            '100%': { transform: 'scale(1)', opacity: 1 },
                        },
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        },
                        shake: {
                            '0%, 100%': { transform: 'translateX(0)' },
                            '10%, 30%, 50%, 70%, 90%': { transform: 'translateX(-10px)' },
                            '20%, 40%, 60%, 80%': { transform: 'translateX(10px)' },
                        },
                    },
                    boxShadow: {
                        'glow': '0 0 15px 2px rgba(93, 92, 222, 0.3)',
                        'glow-lg': '0 0 30px 5px rgba(93, 92, 222, 0.3)',
                        'glow-xl': '0 0 45px 7px rgba(93, 92, 222, 0.3)',
                        'success-glow': '0 0 15px 2px rgba(34, 197, 94, 0.3)',
                        'danger-glow': '0 0 15px 2px rgba(239, 68, 68, 0.3)',
                        'warning-glow': '0 0 15px 2px rgba(245, 158, 11, 0.3)',
                        'info-glow': '0 0 15px 2px rgba(14, 165, 233, 0.3)',
                    },
                    borderRadius: {
                        'xl': '1rem',
                        '2xl': '1.5rem',
                        '3xl': '2rem',
                    },
                },
            },
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Adicionar a biblioteca do Google Sheets API -->
    <script src="https://apis.google.com/js/api.js"></script>
    <style>
        /* Estilos globais */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');
        
        body {
            font-family: 'Poppins', system-ui, sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
            scroll-behavior: smooth;
        }
        
        /* Efeitos de carta 3D */
        .card-3d {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            will-change: transform;
            transform-style: preserve-3d;
            perspective: 1000px;
        }
        
        .card-3d:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        /* Grade de células do Mines */
        .mines-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            transition: opacity 0.3s ease;
        }
        
        /* Células do jogo com efeitos 3D */
        .cell {
            aspect-ratio: 1/1;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            transform-style: preserve-3d;
            perspective: 800px;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        .cell::before {
            content: '';
            position: absolute;
            inset: 0;
            z-index: -1;
            border-radius: inherit;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .cell:hover::before {
            opacity: 1;
        }
        
        .cell:active {
            transform: scale(0.95) translateY(2px);
        }
        
        .cell-safety-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.3;
            pointer-events: none;
            border-radius: inherit;
            transition: opacity 0.3s ease;
        }
        
        .cell:hover .cell-safety-indicator {
            opacity: 0.5;
        }
        
        /* Adaptações para tema escuro */
        .dark .bg-gray-200 {
            background-color: #2d3748;
        }
        
        .dark .text-gray-700 {
            color: #e2e8f0;
        }
        
        .dark .bg-white {
            background-color: #1a202c;
        }
        
        .dark .text-gray-800 {
            color: #f7fafc;
        }
        
        .dark .border-gray-200 {
            border-color: #4a5568;
        }
        
        /* Animações e efeitos visuais */
        .pulse {
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(93, 92, 222, 0.4);
            }
            
            50% {
                transform: scale(1.05);
                opacity: 0.8;
                box-shadow: 0 0 0 10px rgba(93, 92, 222, 0);
            }
        }
        
        /* Cores e temas */
        .dark .bg-orange-500 {
            background-color: #FD7E14;
        }
        
        .bg-orange-500 {
            background-color: #F97316;
        }
        
        .bg-primary {
            background-color: #5D5CDE;
        }
        
        .text-primary {
            color: #5D5CDE;
        }
        
        .dark .bg-primary {
            background-color: #7776FF;
        }
        
        .dark .text-primary {
            color: #7776FF;
        }
        
        .ring-primary:focus {
            --tw-ring-color: #5D5CDE;
        }
        
        .dark .ring-primary:focus {
            --tw-ring-color: #7776FF;
        }
        
        /* Badge para números */
        .ml-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            z-index: 10;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            animation: scaleIn 0.3s ease-out;
        }
        
        /* Modais e diálogos aprimorados */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            width: 90%;
            max-width: 400px;
            background: white;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transform: scale(0.8) translateY(20px);
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
        }
        
        .dark .modal-content {
            background: #1f2937;
            color: white;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1) translateY(0);
        }
        
        /* Itens de histórico com animações */
        .history-item {
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform: translateY(20px);
            opacity: 0;
            box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
            overflow: hidden;
        }
        
        .history-item.visible {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Animações refinadas */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .shimmer {
            background: linear-gradient(90deg, 
                rgba(255,255,255,0) 0%, 
                rgba(255,255,255,0.2) 25%, 
                rgba(255,255,255,0.2) 50%, 
                rgba(255,255,255,0) 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        
        /* Scrollbar personalizada */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .dark ::-webkit-scrollbar-track {
            background: #2d3748;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 10px;
            transition: background 0.3s ease;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
        
        .dark ::-webkit-scrollbar-thumb {
            background: #4a5568;
        }
        
        .dark ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }
        
        /* Tooltip aprimorado */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #1a202c;
            color: #f7fafc;
            text-align: center;
            border-radius: 0.5rem;
            padding: 10px;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(10px);
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            font-size: 12px;
            line-height: 1.5;
        }
        
        .dark .tooltip .tooltiptext {
            background-color: #2d3748;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3), 0 4px 6px -2px rgba(0,0,0,0.2);
        }
        
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1a202c transparent transparent transparent;
        }
        
        .dark .tooltip .tooltiptext::after {
            border-color: #2d3748 transparent transparent transparent;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Barra de status com transições */
        .status-bar {
            background: rgba(93, 92, 222, 0.1);
            border-left: 3px solid #5D5CDE;
            padding: 10px 12px;
            border-radius: 0 8px 8px 0;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
        }
        
        .status-bar:hover {
            transform: translateX(3px);
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        }
        
        .dark .status-bar {
            background: rgba(119, 118, 255, 0.1);
            border-left: 3px solid #7776FF;
        }
        
        /* Timer circular com animação fluida */
        .timer-circle {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: conic-gradient(#5D5CDE 0% var(--progress), #e5e5e5 var(--progress) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            transition: all 0.3s ease;
        }
        
        .timer-circle:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
        }
        
        .dark .timer-circle {
            background: conic-gradient(#7776FF 0% var(--progress), #333 var(--progress) 100%);
        }
        
        .timer-circle::before {
            content: '';
            position: absolute;
            width: 54px;
            height: 54px;
            border-radius: 50%;
            background: white;
            z-index: 1;
            box-shadow: inset 0 2px 6px -1px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
        }
        
        .dark .timer-circle::before {
            background: #1f2937;
            box-shadow: inset 0 2px 6px -1px rgba(0,0,0,0.3);
        }
        
        .timer-text {
            position: relative;
            z-index: 2;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        /* Inputs formatados para moeda com feedback visual */
        input.currency {
            text-align: right;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input.currency:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(93, 92, 222, 0.3);
            border-color: #5D5CDE;
        }
        
        .dark input.currency:focus {
            box-shadow: 0 0 0 3px rgba(119, 118, 255, 0.3);
            border-color: #7776FF;
        }
        
        /* Modo inativo com transição suave */
        .main-container {
            transition: filter 0.5s ease, opacity 0.5s ease;
        }
        
        .inactive-mode {
            filter: grayscale(0.7) blur(1px);
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Animações para botões */
        button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        button:active {
            transform: scale(0.97);
        }
        
        button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.4);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }
        
        button:focus:not(:active)::after {
            animation: ripple 0.6s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            100% {
                transform: scale(40, 40);
                opacity: 0;
            }
        }
        
        /* Efeitos de hover para cards */
        .hover-card {
            position: relative;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .hover-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent 0%, rgba(255,255,255,0.05) 50%, transparent 100%);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }
        
        .hover-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
        }
        
        .hover-card:hover::before {
            transform: translateX(100%);
        }
        
        /* Animação de carregamento */
        .loading-dots::after {
            content: '...';
            display: inline-block;
            animation: loading 1.2s infinite;
            width: 1.5em;
            text-align: left;
        }
        
        @keyframes loading {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
        }
    </style>
</head>
<body class="bg-gradient-to-b from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-800 text-gray-800 transition-colors duration-300 dark:text-gray-200 min-h-screen">
    <!-- Partículas de fundo -->
    <div id="particles-background" class="fixed inset-0 z-0 opacity-30 pointer-events-none"></div>
    
    <!-- Tela Inicial -->
    <div id="initialScreen" class="fixed inset-0 bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-800 z-50 overflow-y-auto">
        <div class="min-h-screen flex flex-col items-center justify-center p-4">
            <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full p-8 mb-6 card-3d relative overflow-hidden border border-gray-100 dark:border-gray-700 animate-fade-in">
                <!-- Elemento decorativo -->
                <div class="absolute -top-16 -right-16 w-32 h-32 bg-primary bg-opacity-10 dark:bg-opacity-20 rounded-full"></div>
                <div class="absolute -bottom-16 -left-16 w-32 h-32 bg-purple-500 bg-opacity-10 dark:bg-opacity-20 rounded-full"></div>
                
                <div class="text-center mb-8 relative">
                    <div class="w-24 h-24 bg-gradient-to-br from-primary to-purple-600 rounded-2xl flex items-center justify-center mx-auto mb-6 transform -rotate-6 shadow-glow animate-float">
                        <i class="fas fa-gem text-white text-4xl"></i>
                    </div>
                    <h1 class="text-3xl font-bold mb-3 text-gray-900 dark:text-white bg-clip-text text-transparent bg-gradient-to-r from-primary to-purple-600">Estratégia Mines IA</h1>
                    <p class="text-gray-600 dark:text-gray-400">Algoritmos avançados para otimizar seus resultados</p>
                </div>
                
                <div class="space-y-6 mb-8">
                    <div class="flex items-start hover-card p-3 rounded-xl transition-all duration-300 hover:bg-gray-50 dark:hover:bg-gray-700/50">
                        <div class="bg-gradient-to-br from-primary to-blue-500 rounded-xl p-3 mr-4 shadow-md">
                            <i class="fas fa-robot text-white text-xl"></i>
                        </div>
                        <div>
                            <h3 class="font-semibold text-gray-900 dark:text-white">Inteligência Artificial</h3>
                            <p class="text-sm text-gray-600 dark:text-gray-400">Modelos avançados de IA para análise de probabilidades e padrões</p>
                        </div>
                    </div>
                    
                    <div class="flex items-start hover-card p-3 rounded-xl transition-all duration-300 hover:bg-gray-50 dark:hover:bg-gray-700/50">
                        <div class="bg-gradient-to-br from-green-500 to-teal-500 rounded-xl p-3 mr-4 shadow-md">
                            <i class="fas fa-chart-line text-white text-xl"></i>
                        </div>
                        <div>
                            <h3 class="font-semibold text-gray-900 dark:text-white">Gestão de Banca</h3>
                            <p class="text-sm text-gray-600 dark:text-gray-400">Sistema integrado com controle de stop win/loss para proteção do seu capital</p>
                        </div>
                    </div>
                    
                    <div class="flex items-start hover-card p-3 rounded-xl transition-all duration-300 hover:bg-gray-50 dark:hover:bg-gray-700/50">
                        <div class="bg-gradient-to-br from-orange-500 to-red-500 rounded-xl p-3 mr-4 shadow-md">
                            <i class="fas fa-shield-alt text-white text-xl"></i>
                        </div>
                        <div>
                            <h3 class="font-semibold text-gray-900 dark:text-white">Acesso Exclusivo</h3>
                            <p class="text-sm text-gray-600 dark:text-gray-400">Estratégia disponível apenas para usuários com acesso confirmado</p>
                        </div>
                    </div>
                </div>
                
                <button id="openLoginBtn" class="w-full py-4 bg-gradient-to-r from-primary to-purple-600 text-white font-bold rounded-xl hover:shadow-lg transition-all duration-300 flex items-center justify-center relative overflow-hidden group">
                    <span class="absolute w-0 h-0 transition-all duration-500 ease-out bg-white rounded-full group-hover:w-56 group-hover:h-56 opacity-10"></span>
                    <i class="fas fa-sign-in-alt mr-2"></i> 
                    <span class="relative">LOGIN</span>
                </button>
            </div>
            
            <div class="text-center text-gray-500 dark:text-gray-400 text-xs animate-fade-in" style="animation-delay: 0.3s">
                <p>Use com responsabilidade. Aposte apenas o que você pode perder.</p>
                <p class="mt-1">© 2023 Estratégia Mines IA • Todos os direitos reservados</p>
            </div>
        </div>
    </div>
    
    <!-- Modal de Login -->
    <div id="loginModal" class="modal-overlay">
        <div class="modal-content dark:bg-gray-800" style="max-width: 400px;">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary to-purple-600">Acesso Exclusivo</h2>
                <button id="closeLoginBtn" class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-colors duration-300 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div id="loginMessage" class="mb-4 text-center p-3 rounded-lg border-l-4 border-red-500 bg-red-50 dark:bg-red-900/20 dark:border-red-600 hidden">
                <p class="text-sm text-red-600 dark:text-red-400"></p>
            </div>
            
            <div id="loginLoading" class="mb-4 text-center hidden">
                <div class="inline-block relative w-16 h-16 mb-3">
                    <div class="absolute border-4 border-primary/30 border-t-primary rounded-full w-16 h-16 animate-spin"></div>
                </div>
                <p class="text-sm font-medium text-gray-600 dark:text-gray-400">Carregando dados<span class="loading-dots"></span></p>
            </div>
            
            <form id="loginForm" class="space-y-5">
                <div class="space-y-2">
                    <label class="block text-sm font-medium flex items-center">
                        <i class="fas fa-envelope text-primary mr-2"></i>
                        Email
                    </label>
                    <div class="relative">
                        <input type="email" id="loginEmail" 
                            class="block w-full pl-4 pr-10 py-3 border border-gray-300 dark:border-gray-600 rounded-xl shadow-sm focus:ring-primary focus:border-primary dark:bg-gray-700/70 dark:text-white text-base transition-all duration-300" 
                            placeholder="Seu email" required>
                        <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none text-gray-400">
                            <i class="fas fa-at"></i>
                        </div>
                    </div>
                </div>
                
                <div class="space-y-2">
                    <label class="block text-sm font-medium flex items-center">
                        <i class="fas fa-lock text-primary mr-2"></i>
                        Senha
                    </label>
                    <div class="relative">
                        <input type="password" id="loginPassword" 
                            class="block w-full pl-4 pr-10 py-3 border border-gray-300 dark:border-gray-600 rounded-xl shadow-sm focus:ring-primary focus:border-primary dark:bg-gray-700/70 dark:text-white text-base transition-all duration-300" 
                            placeholder="Sua senha" required>
                        <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none text-gray-400">
                            <i class="fas fa-key"></i>
                        </div>
                    </div>
                </div>
                
                <div class="pt-4">
                    <button type="submit" id="loginButton" class="w-full py-4 bg-gradient-to-r from-primary to-purple-600 text-white font-bold rounded-xl hover:shadow-lg transition-all duration-300 relative overflow-hidden group">
                        <span class="absolute w-0 h-0 transition-all duration-500 ease-out bg-white rounded-full group-hover:w-56 group-hover:h-56 opacity-10"></span>
                        <i class="fas fa-sign-in-alt mr-2"></i>
                        <span class="relative">ENTRAR</span>
                    </button>
                </div>
            </form>
            
            <div class="mt-5 text-center text-gray-500 dark:text-gray-400 text-xs">
                <p>Acesso exclusivo para usuários cadastrados</p>
            </div>
        </div>
    </div>

    <!-- Tela inicial para configuração de valores -->
    <div id="setupModal" class="modal-overlay">
        <div class="modal-content dark:bg-gray-800">
            <h2 class="text-xl font-bold mb-6 text-center text-primary">Configurar Estratégia</h2>
            
            <form id="setupForm" class="space-y-4">
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Saldo Inicial (R$)</label>
                    <div class="relative">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <span class="text-gray-500">R$</span>
                        </div>
                        <input type="text" inputmode="decimal" id="initialBalance" class="money-input block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary focus:border-primary dark:bg-gray-700 dark:text-white text-right" required>
                    </div>
                </div>
                
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Stop Win (R$)</label>
                    <div class="relative">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <span class="text-gray-500">R$</span>
                        </div>
                        <input type="text" inputmode="decimal" id="stopWin" class="money-input block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary focus:border-primary dark:bg-gray-700 dark:text-white text-right" required>
                    </div>
                </div>
                
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Stop Loss (R$)</label>
                    <div class="relative">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <span class="text-gray-500">R$</span>
                        </div>
                        <input type="text" inputmode="decimal" id="stopLoss" class="money-input block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary focus:border-primary dark:bg-gray-700 dark:text-white text-right" required>
                    </div>
                </div>
                
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Valor da Aposta (R$)</label>
                    <div class="relative">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <span class="text-gray-500">R$</span>
                        </div>
                        <input type="text" inputmode="decimal" id="betAmount" class="money-input block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary focus:border-primary dark:bg-gray-700 dark:text-white text-right" required>
                    </div>
                </div>
                
                <div class="pt-4">
                    <button type="submit" class="w-full py-3 bg-primary text-white font-bold rounded-lg hover:opacity-90 transition-opacity">
                        INICIAR ESTRATÉGIA
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div id="mainContainer" class="container mx-auto px-4 py-8 max-w-lg">
        <header class="mb-8 fade-in">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                <div class="flex items-center">
                    <div class="w-12 h-12 bg-gradient-to-br from-primary to-purple-600 rounded-xl shadow-lg flex items-center justify-center mr-3 transform -rotate-6">
                        <i class="fas fa-gem text-white text-xl"></i>
                    </div>
                    <h1 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-primary to-purple-600">Estratégia Mines IA</h1>
                </div>
                <div id="userGreeting" class="text-sm font-medium px-4 py-2 bg-gradient-to-r from-primary/10 to-purple-500/10 dark:from-primary/20 dark:to-purple-500/20 rounded-full shadow-sm hidden animate-pulse-fast">
                    <i class="fas fa-user-circle mr-1"></i> Olá, <span id="userFirstName" class="font-semibold">Usuário</span>!
                </div>
            </div>
            <div class="text-sm text-gray-600 dark:text-gray-400 text-center sm:text-left bg-gray-100 dark:bg-gray-800/50 p-2 rounded-lg inline-block shadow-sm">
                <i class="fas fa-robot mr-1 text-primary"></i> Com algoritmos de IA avançados para análise em tempo real
            </div>
        </header>
        
        <!-- Painel de Gestão de Banca -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 mb-4 border border-gray-200 fade-in" style="animation-delay: 0.1s;">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-semibold">Gestão de Banca</h3>
                <button id="configBankBtn" class="text-xs px-2 py-1 bg-primary text-white rounded hover:opacity-90 transition-colors">
                    <i class="fas fa-cog mr-1"></i> Configurações
                </button>
            </div>
            
            <div class="grid grid-cols-2 gap-3 mb-3">
                <div class="status-bar dark:text-gray-300">
                    <div class="text-xs text-gray-500 dark:text-gray-400">Saldo Atual</div>
                    <div id="currentBalance" class="font-semibold">R$ 0,00</div>
                </div>
                <div class="status-bar dark:text-gray-300">
                    <div class="text-xs text-gray-500 dark:text-gray-400">Lucro/Prejuízo</div>
                    <div id="profitLoss" class="font-semibold">R$ 0,00</div>
                </div>
            </div>
            
            <!-- Stop Win/Loss Progress -->
            <div class="mb-3">
                <div class="flex justify-between items-center mb-1">
                    <div class="text-xs text-gray-500 dark:text-gray-400">
                        <span>Stop Win</span>
                    </div>
                    <div class="text-xs font-semibold text-green-600 dark:text-green-400">
                        <span id="stopWinValue">R$ 0,00</span>
                        (<span id="stopWinPercentage">0%</span>)
                    </div>
                </div>
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-3">
                    <div id="stopWinProgress" class="bg-green-500 h-2.5 rounded-full transition-all duration-500" style="width: 0%"></div>
                </div>
                
                <div class="flex justify-between items-center mb-1">
                    <div class="text-xs text-gray-500 dark:text-gray-400">
                        <span>Stop Loss</span>
                    </div>
                    <div class="text-xs font-semibold text-red-600 dark:text-red-400">
                        <span id="stopLossValue">R$ 0,00</span>
                        (<span id="stopLossPercentage">0%</span>)
                    </div>
                </div>
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
                    <div id="stopLossProgress" class="bg-red-500 h-2.5 rounded-full transition-all duration-500" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="grid grid-cols-3 gap-3">
                <div class="text-center">
                    <div class="text-xs text-gray-500 dark:text-gray-400">Aposta Atual</div>
                    <div id="currentBet" class="font-semibold">R$ 0,00</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 dark:text-gray-400">Modo</div>
                    <div id="betMode" class="font-semibold">Normal</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 dark:text-gray-400">Multiplicador</div>
                    <div id="multiplier" class="font-semibold">2.05x</div>
                </div>
            </div>
        </div>
        
        <!-- Confiança da IA -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 mb-4 border border-gray-200 fade-in" style="animation-delay: 0.15s;">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-lg font-semibold flex items-center">
                    Confiança da IA
                    <div class="tooltip ml-2">
                        <i class="fas fa-info-circle text-gray-500"></i>
                        <span class="tooltiptext">Quanto maior a confiança, mais certeza a IA tem sobre suas recomendações baseadas nos dados analisados.</span>
                    </div>
                </h3>
                <span id="confidenceText" class="text-sm font-medium bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded-full">50%</span>
            </div>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                <div id="confidenceBar" class="bg-green-500 h-4 rounded-full transition-all duration-500" style="width: 50%"></div>
            </div>
            <div class="flex justify-between text-xs mt-1">
                <span class="text-red-500">Arriscado</span>
                <span class="text-green-500">Seguro</span>
            </div>
        </div>
        
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6 border border-gray-200 fade-in" style="animation-delay: 0.2s;">
            <h2 class="text-xl font-semibold mb-4 text-center">Tabuleiro</h2>
            <p class="text-sm text-gray-700 dark:text-gray-300 mb-4 text-center">Tabuleiro 5x5 com 4 bombas</p>
            
            <div class="mines-grid mb-6">
                <!-- As células serão geradas por JavaScript -->
            </div>
            
            <div class="space-y-4">
                <button id="analyzeBtn" class="w-full py-3 bg-primary text-white font-bold rounded-lg hover:opacity-90 transition-opacity flex items-center justify-center">
                    <i class="fas fa-search mr-2"></i> ANALISAR JOGADA
                </button>
            </div>
        </div>

        <!-- Modelo de IA -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 mb-6 border border-gray-200 fade-in" style="animation-delay: 0.3s;">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-lg font-semibold">Modelos Avançados</h3>
                <span id="currentStrategy" class="text-sm font-medium bg-primary px-2 py-1 text-white rounded-full">Ensemble</span>
            </div>
            <div class="grid grid-cols-3 gap-2 mb-3">
                <div class="text-center p-2 rounded bg-gray-100 dark:bg-gray-700">
                    <div class="text-xs text-gray-600 dark:text-gray-400">Bayesiano</div>
                    <div id="bayesianWeight" class="font-semibold">40%</div>
                </div>
                <div class="text-center p-2 rounded bg-gray-100 dark:bg-gray-700">
                    <div class="text-xs text-gray-600 dark:text-gray-400">Padrões</div>
                    <div id="patternWeight" class="font-semibold">30%</div>
                </div>
                <div class="text-center p-2 rounded bg-gray-100 dark:bg-gray-700">
                    <div class="text-xs text-gray-600 dark:text-gray-400">Monte Carlo</div>
                    <div id="monteCarloWeight" class="font-semibold">30%</div>
                </div>
            </div>
            <div class="text-xs text-gray-600 dark:text-gray-400 text-center">
                Ensemble adaptativo de modelos de IA para máxima assertividade
            </div>
        </div>
        
        <!-- Histórico de Jogadas -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 mb-6 border border-gray-200 fade-in" style="animation-delay: 0.4s;">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold">Histórico de Jogadas</h3>
                <button id="clearHistoryBtn" class="text-xs px-2 py-1 text-red-500 border border-red-500 rounded hover:bg-red-500 hover:text-white transition-colors">
                    <i class="fas fa-trash"></i> Limpar
                </button>
            </div>
            <div id="historyContainer" class="max-h-60 overflow-y-auto">
                <div id="emptyHistory" class="text-center text-gray-500 py-4">
                    Sem histórico de jogadas
                </div>
                <div id="historyList"></div>
            </div>
        </div>
        
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 border border-gray-200 fade-in" style="animation-delay: 0.5s;">
            <h2 class="text-xl font-semibold mb-2">Estatísticas</h2>
            <div class="grid grid-cols-3 gap-2 mb-4">
                <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                    <p class="text-sm text-gray-700 dark:text-gray-300">1ª Tentativa</p>
                    <p id="firstTrySuccessCount" class="text-2xl font-bold">0</p>
                </div>
                <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                    <p class="text-sm text-gray-700 dark:text-gray-300">Com Martingale</p>
                    <p id="martingaleSuccessCount" class="text-2xl font-bold">0</p>
                </div>
                <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                    <p class="text-sm text-gray-700 dark:text-gray-300">Perdas</p>
                    <p id="explosionCount" class="text-2xl font-bold">0</p>
                </div>
            </div>
            <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                <p class="text-sm text-gray-700 dark:text-gray-300">Taxa de sucesso</p>
                <p id="successRate" class="text-2xl font-bold">0%</p>
            </div>
        </div>
        
        <!-- Rodapé -->
        <footer class="text-center text-gray-500 mt-8 text-xs p-4 fade-in" style="animation-delay: 0.6s;">
            <p>Sistema de IA avançada para otimização de jogadas no Mines</p>
            <p class="mt-1">Com gestão de banca e estratégia de recuperação inteligente</p>
            
            <button id="endSessionBtn" class="mt-4 py-2 px-4 bg-red-600 text-white rounded-lg text-sm hover:bg-red-700 transition-colors">
                <i class="fas fa-power-off mr-1"></i> ENCERRAR SESSÃO
            </button>
        </footer>
    </div>
    
    <!-- Modal para resultados -->
    <div id="resultModal" class="modal-overlay">
        <div class="modal-content dark:bg-gray-800">
            <h2 class="text-xl font-semibold mb-4 text-center">Resultado da Jogada</h2>
            
            <!-- Botões de resultado -->
            <div class="space-y-3">
                <button id="wonFirstTryBtn" class="w-full py-2 bg-green-500 text-white font-bold rounded-lg hover:opacity-90 transition-opacity flex items-center justify-center">
                    <i class="fas fa-check-circle mr-2"></i> ACERTOU DE PRIMEIRA
                </button>
                <button id="wonMartingaleBtn" class="w-full py-2 bg-blue-500 text-white font-bold rounded-lg hover:opacity-90 transition-opacity flex items-center justify-center">
                    <i class="fas fa-sync-alt mr-2"></i> ACERTOU COM MARTINGALE
                </button>
                <button id="lostBtn" class="w-full py-2 bg-red-600 text-white font-bold rounded-lg hover:opacity-90 transition-opacity flex items-center justify-center">
                    <i class="fas fa-times-circle mr-2"></i> PERDEU MESMO COM MARTINGALE
                </button>
            </div>
            
            <!-- Seletor de célula que explodiu na primeira tentativa -->
            <div id="firstExplosionPanel" class="mt-4 hidden">
                <p class="text-center font-semibold mb-2">Qual quadrado explodiu na 1ª tentativa?</p>
                <div class="grid grid-cols-4 gap-2">
                    <button class="explosion-btn py-2 bg-orange-500 hover:bg-orange-600 text-white font-bold rounded-lg" data-position="1">1</button>
                    <button class="explosion-btn py-2 bg-orange-500 hover:bg-orange-600 text-white font-bold rounded-lg" data-position="2">2</button>
                    <button class="explosion-btn py-2 bg-orange-500 hover:bg-orange-600 text-white font-bold rounded-lg" data-position="3">3</button>
                    <button class="explosion-btn py-2 bg-orange-500 hover:bg-orange-600 text-white font-bold rounded-lg" data-position="4">4</button>
                </div>
            </div>
            
            <!-- Seletor de célula que explodiu na segunda tentativa -->
            <div id="secondExplosionPanel" class="mt-4 hidden">
                <p class="text-center font-semibold mb-2">Qual quadrado explodiu na 2ª tentativa?</p>
                <div class="grid grid-cols-4 gap-2">
                    <button class="explosion-btn-second py-2 bg-red-500 hover:bg-red-600 text-white font-bold rounded-lg" data-position="1">1</button>
                    <button class="explosion-btn-second py-2 bg-red-500 hover:bg-red-600 text-white font-bold rounded-lg" data-position="2">2</button>
                    <button class="explosion-btn-second py-2 bg-red-500 hover:bg-red-600 text-white font-bold rounded-lg" data-position="3">3</button>
                    <button class="explosion-btn-second py-2 bg-red-500 hover:bg-red-600 text-white font-bold rounded-lg" data-position="4">4</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal de Timeout/Pause -->
    <div id="timeoutModal" class="modal-overlay">
        <div class="modal-content dark:bg-gray-800">
            <div class="flex flex-col items-center text-center">
                <div class="text-xl font-bold mb-4">
                    <span id="timeoutTitle">Stop Atingido</span>
                </div>
                
                <div class="mb-6 text-center">
                    <p id="timeoutMessage" class="mb-3">Você atingiu seu objetivo de lucro! O sistema ficará pausado por 1 hora para ajudar no controle emocional.</p>
                    
                    <div class="timer-circle mb-2 mx-auto" style="--progress: 0%">
                        <span id="timerText" class="timer-text">60:00</span>
                    </div>
                    
                    <p class="text-sm text-gray-500 dark:text-gray-400">
                        Tempo restante para nova sessão
                    </p>
                </div>
                
                <div id="timeoutButtons" class="w-full">
                    <button id="resetTimeBtn" class="w-full py-2 bg-primary text-white font-bold rounded-lg hover:opacity-90 transition-opacity">
                        REINICIAR
                    </button>
                </div>
                
                <!-- Área para entrada de senha (inicialmente oculta) -->
                <div id="passwordInputArea" class="w-full mt-3 hidden">
                    <div class="text-sm mb-2 text-red-500 dark:text-red-400">Para reiniciar o bloqueio de stop, insira a senha:</div>
                    <div class="flex space-x-2">
                        <input type="password" inputmode="numeric" pattern="[0-9]*" id="unlockPassword" class="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary focus:border-primary dark:bg-gray-700 dark:text-white text-base" placeholder="Digite a senha">
                        <button id="confirmUnlockBtn" class="px-4 py-2 bg-primary text-white font-bold rounded-lg hover:opacity-90 transition-opacity">
                            <i class="fas fa-check"></i>
                        </button>
                    </div>
                    <div id="passwordError" class="text-sm text-red-500 mt-1 hidden">Senha incorreta!</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Detectar modo escuro
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        /**
         * Modelo Bayesiano: Utiliza estatísticas bayesianas para estimar probabilidades
         */
        class BayesianModel {
            constructor() {
                // Inicializar com probabilidades neutras (0.5)
                this.cellProbabilities = Array(25).fill(0.5);
                // Prior para novas células (com pouca evidência)
                this.priorStrength = 5;
                // Cópia da probabilidade original para visualização
                this.originalProbabilities = [...this.cellProbabilities];
                // Histórico de acertos e erros para cada célula
                this.cellHistory = Array(25).fill(0).map(() => ({ success: 0, failure: 0 }));
                // Flag para modo de recuperação
                this.recoveryMode = false;
            }
            
            loadFromSaved(savedData) {
                if (savedData && savedData.cellProbabilities) {
                    this.cellProbabilities = savedData.cellProbabilities;
                    this.priorStrength = savedData.priorStrength || this.priorStrength;
                    this.originalProbabilities = [...this.cellProbabilities];
                    this.cellHistory = savedData.cellHistory || this.cellHistory;
                    return true;
                }
                return false;
            }
            
            toJSON() {
                return {
                    cellProbabilities: this.cellProbabilities,
                    priorStrength: this.priorStrength,
                    cellHistory: this.cellHistory
                };
            }
            
            // Ativar ou desativar modo de recuperação
            setRecoveryMode(isRecoveryMode) {
                this.recoveryMode = isRecoveryMode;
            }
            
            update(selection, explosionPositions, wasSuccessful) {
                // Atualizar histórico de células
                for (let i = 0; i < 25; i++) {
                    if (selection.includes(i)) {
                        if (explosionPositions.includes(i)) {
                            this.cellHistory[i].failure++;
                        } else {
                            this.cellHistory[i].success++;
                        }
                    }
                }
                
                // Para cada célula no tabuleiro
                for (let i = 0; i < 25; i++) {
                    // Se foi selecionada e explodiu
                    if (selection.includes(i) && explosionPositions.includes(i)) {
                        // Aumentar significativamente a probabilidade de ser perigosa
                        this.updateCellProbability(i, 0.9);
                    } 
                    // Se foi selecionada e não explodiu
                    else if (selection.includes(i) && !explosionPositions.includes(i)) {
                        // Diminuir a probabilidade de ser perigosa (aumentar segurança)
                        this.updateCellProbability(i, 0.1);
                    }
                    
                    // Análise de células adjacentes a explosões
                    if (explosionPositions.length > 0) {
                        explosionPositions.forEach(pos => {
                            const adjacentCells = this.getAdjacentCells(pos);
                            if (adjacentCells.includes(i)) {
                                // Células adjacentes têm probabilidade maior em modo normal
                                const adjacentRisk = this.recoveryMode ? 0.55 : 0.7;
                                this.updateCellProbability(i, adjacentRisk);
                            }
                        });
                    }
                }
                
                // Análise adicional para o modo de recuperação
                if (this.recoveryMode) {
                    // No modo de recuperação, damos mais peso para células com histórico de sucesso
                    for (let i = 0; i < 25; i++) {
                        const history = this.cellHistory[i];
                        const totalPlays = history.success + history.failure;
                        
                        if (totalPlays > 0) {
                            const successRate = history.success / totalPlays;
                            
                            // Se tem uma alta taxa de sucesso, diminuir ainda mais o risco
                            if (successRate > 0.7 && totalPlays >= 3) {
                                this.updateCellProbability(i, 0.2); // Muito segura
                            }
                            // Se tem histórico ruim, aumentar o risco
                            else if (successRate < 0.3 && totalPlays >= 2) {
                                this.updateCellProbability(i, 0.8); // Muito perigosa
                            }
                        }
                    }
                }
                
                // Guardar uma cópia para visualização
                this.originalProbabilities = [...this.cellProbabilities];
            }
            
            // Obter células adjacentes a uma célula
            getAdjacentCells(cellIndex) {
                const row = Math.floor(cellIndex / 5);
                const col = cellIndex % 5;
                const adjacent = [];
                
                // Verificar células adjacentes (até 8 possíveis em um grid 5x5)
                for (let r = Math.max(0, row-1); r <= Math.min(4, row+1); r++) {
                    for (let c = Math.max(0, col-1); c <= Math.min(4, col+1); c++) {
                        const idx = r * 5 + c;
                        if (idx !== cellIndex) {
                            adjacent.push(idx);
                        }
                    }
                }
                
                return adjacent;
            }
            
            updateCellProbability(cellIndex, newEvidence) {
                // Atualização bayesiana: combina prior com nova evidência
                const prior = this.cellProbabilities[cellIndex];
                const likelihood = newEvidence;
                
                // Em modo de recuperação, damos mais peso à nova evidência
                const priorWeight = this.recoveryMode ? Math.max(1, this.priorStrength / 2) : this.priorStrength;
                
                // Fórmula de Bayes simplificada com pesos
                const posterior = (prior * priorWeight + likelihood) / (priorWeight + 1);
                this.cellProbabilities[cellIndex] = posterior;
                
                // Aumentar gradualmente o peso do prior conforme mais evidências são coletadas
                this.priorStrength = Math.min(20, this.priorStrength + 0.1);
            }
            
            // Retorna as células mais seguras (menor probabilidade de explosão)
            getSafestCells(count) {
                // Criar array de {index, probability}
                const cellsWithProbs = this.cellProbabilities.map((prob, index) => ({
                    index, 
                    safetyScore: 1 - prob // Converter probabilidade de explosão para segurança
                }));
                
                // Ordenar do mais seguro para menos seguro
                cellsWithProbs.sort((a, b) => b.safetyScore - a.safetyScore);
                
                // Retornar os índices mais seguros
                return cellsWithProbs.slice(0, count).map(cell => cell.index);
            }
            
            // Obter todas as células com suas probabilidades
            getAllCellsWithProbabilities() {
                return this.cellProbabilities.map((prob, index) => ({
                    index,
                    safetyScore: 1 - prob // Converter probabilidade de explosão para segurança
                }));
            }
            
            // Obter confiança do modelo
            getConfidence() {
                // Calcular variância dos valores (maior variância = maior confiança)
                const mean = this.cellProbabilities.reduce((sum, val) => sum + val, 0) / 25;
                const variance = this.cellProbabilities.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / 25;
                
                // Em modo de recuperação, aumentar a confiança base
                const baseConfidence = this.recoveryMode ? 40 : 20;
                
                // Mapear variância para confiança (0-100)
                return Math.min(95, Math.max(baseConfidence, Math.round(variance * 500)));
            }
        }
        
        /**
         * Memória de Padrões: Memoriza padrões específicos de sucesso e falha
         */
        class PatternMemory {
            constructor() {
                this.successfulPatterns = [];
                this.failedPatterns = [];
                this.patternSimilarityThreshold = 0.6; // Quão similar um padrão precisa ser
                this.recoveryMode = false;
                this.consecutiveFailures = 0;
            }
            
            loadFromSaved(savedData) {
                if (savedData) {
                    this.successfulPatterns = savedData.successfulPatterns || [];
                    this.failedPatterns = savedData.failedPatterns || [];
                    this.patternSimilarityThreshold = savedData.patternSimilarityThreshold || this.patternSimilarityThreshold;
                    this.consecutiveFailures = savedData.consecutiveFailures || 0;
                    return true;
                }
                return false;
            }
            
            toJSON() {
                return {
                    successfulPatterns: this.successfulPatterns,
                    failedPatterns: this.failedPatterns,
                    patternSimilarityThreshold: this.patternSimilarityThreshold,
                    consecutiveFailures: this.consecutiveFailures
                };
            }
            
            // Ativar ou desativar modo de recuperação
            setRecoveryMode(isRecoveryMode) {
                this.recoveryMode = isRecoveryMode;
            }
            
            addPattern(selection, result, explosionPositions) {
                const pattern = {
                    selection: [...selection],
                    explosionPositions: [...explosionPositions],
                    timestamp: Date.now(),
                    recoveryMode: this.recoveryMode
                };
                
                // Atualizar contagem de falhas consecutivas
                if (result === 'failure') {
                    this.consecutiveFailures++;
                } else {
                    this.consecutiveFailures = 0;
                }
                
                if (result === 'success_first_try' || result === 'success_with_martingale') {
                    this.successfulPatterns.push(pattern);
                    // Limitar tamanho
                    if (this.successfulPatterns.length > 50) this.successfulPatterns.shift();
                } else {
                    this.failedPatterns.push(pattern);
                    // Limitar tamanho
                    if (this.failedPatterns.length > 50) this.failedPatterns.shift();
                }
            }
            
            // Calcular similaridade entre duas seleções
            calculateSimilarity(selection1, selection2) {
                const intersectionSize = selection1.filter(cell => selection2.includes(cell)).length;
                return intersectionSize / 4; // 4 é o tamanho da seleção
            }
            
            // Procurar padrões similares no histórico
            findSimilarPatterns(currentSelection) {
                // Se estamos em modo de recuperação, dar preferência para padrões de recuperação bem-sucedidos
                const similarSuccessful = this.successfulPatterns.filter(pattern => {
                    // Em modo de recuperação, priorizar padrões que também foram em modo de recuperação
                    const modeBonus = (this.recoveryMode && pattern.recoveryMode) ? 0.1 : 0;
                    return this.calculateSimilarity(currentSelection, pattern.selection) >= (this.patternSimilarityThreshold - modeBonus);
                });
                
                // Para falhas, incluir todos os padrões similares
                const similarFailed = this.failedPatterns.filter(pattern => 
                    this.calculateSimilarity(currentSelection, pattern.selection) >= this.patternSimilarityThreshold
                );
                
                return { similarSuccessful, similarFailed };
            }
            
            // Gerar um score para cada célula baseado em padrões similares
            generateCellScores() {
                // Inicializar scores neutros
                const cellScores = Array(25).fill(0);
                
                // Adicionar pontos positivos para células em padrões bem-sucedidos
                this.successfulPatterns.forEach(pattern => {
                    // Dar mais peso para padrões recentes
                    const recencyWeight = this.getRecencyWeight(pattern.timestamp);
                    // Dar mais peso para padrões relevantes ao modo atual
                    const modeWeight = (this.recoveryMode === pattern.recoveryMode) ? 1.5 : 1.0;
                    
                    pattern.selection.forEach(cell => {
                        cellScores[cell] += 1 * recencyWeight * modeWeight;
                    });
                });
                
                // Subtrair pontos para células que explodiram
                this.failedPatterns.forEach(pattern => {
                    // Aumentar penalidade em modo de recuperação
                    const modeMultiplier = this.recoveryMode ? 3 : 2;
                    // Dar mais peso para falhas recentes
                    const recencyWeight = this.getRecencyWeight(pattern.timestamp);
                    
                    pattern.explosionPositions.forEach(cell => {
                        cellScores[cell] -= modeMultiplier * recencyWeight; // Penalizar mais as explosões
                    });
                });
                
                // Penalização extra após falhas consecutivas
                if (this.consecutiveFailures > 0) {
                    // Se temos falhas consecutivas, penalizar mais as células que falharam recentemente
                    const recentFailures = this.failedPatterns.slice(-3);
                    recentFailures.forEach(pattern => {
                        pattern.explosionPositions.forEach(cell => {
                            cellScores[cell] -= this.consecutiveFailures * 2; // Penalidade crescente
                        });
                    });
                }
                
                // Normalizar para 0-1
                const min = Math.min(...cellScores);
                const max = Math.max(...cellScores);
                
                if (max > min) {
                    return cellScores.map(score => 0.5 + (score - min) / (max - min) * 0.4);
                }
                
                return cellScores.map(() => 0.5);
            }
            
            // Calcular peso baseado em quão recente é um padrão
            getRecencyWeight(timestamp) {
                const now = Date.now();
                const ageInHours = (now - timestamp) / (1000 * 60 * 60);
                
                // Padrões mais recentes têm mais peso
                if (ageInHours < 1) return 1.5;    // última hora
                if (ageInHours < 6) return 1.2;    // últimas 6 horas
                if (ageInHours < 24) return 1.0;   // último dia
                if (ageInHours < 72) return 0.7;   // últimos 3 dias
                return 0.5;                        // mais antigos
            }
            
            // Obter células recomendadas baseadas nos padrões
            getRecommendedCells(count) {
                const scores = this.generateCellScores();
                
                // Criar array de {index, score}
                const cellsWithScores = scores.map((score, index) => ({ index, score }));
                
                // Ordenar do maior score para o menor
                cellsWithScores.sort((a, b) => b.score - a.score);
                
                // Retornar os índices com maiores scores
                return cellsWithScores.slice(0, count).map(cell => cell.index);
            }
            
            // Obter confiança do modelo
            getConfidence() {
                const totalPatterns = this.successfulPatterns.length + this.failedPatterns.length;
                
                if (totalPatterns < 5) return 20; // Pouca confiança se poucos dados
                
                // Em modo de recuperação, vamos usar uma abordagem diferente
                if (this.recoveryMode) {
                    // Calcular quantidade de padrões bem-sucedidos em modo de recuperação
                    const recoverySuccesses = this.successfulPatterns.filter(p => p.recoveryMode).length;
                    
                    // Se temos histórico de sucesso em recuperação, alta confiança
                    if (recoverySuccesses > 2) {
                        return Math.min(95, 75 + recoverySuccesses * 2);
                    }
                    
                    // Se estamos em recuperação mas nunca tivemos sucesso nesse modo, menos confiança
                    return 65;
                }
                
                // Mais padrões = mais confiança, mas com limite
                return Math.min(85, 20 + totalPatterns * 2);
            }
        }
        
        /**
         * Simulador de Monte Carlo: Estima probabilidades através de simulações aleatórias
         */
        class MonteCarloSimulator {
            constructor() {
                this.simulationCount = 1000; // Número de simulações
                this.bombCount = 4; // 4 bombas no jogo Mines
                this.lastResults = null; // Último resultado de simulação
                this.lastConfidence = 40; // Confiança inicial moderada
                this.recoveryMode = false; // Modo de recuperação desativado
                this.cellBias = Array(25).fill(1); // Sem viés inicialmente
            }
            
            loadFromSaved(savedData) {
                if (savedData) {
                    this.simulationCount = savedData.simulationCount || this.simulationCount;
                    this.lastResults = savedData.lastResults;
                    this.lastConfidence = savedData.lastConfidence || this.lastConfidence;
                    this.cellBias = savedData.cellBias || Array(25).fill(1);
                    return true;
                }
                return false;
            }
            
            toJSON() {
                return {
                    simulationCount: this.simulationCount,
                    lastResults: this.lastResults,
                    lastConfidence: this.lastConfidence,
                    cellBias: this.cellBias
                };
            }
            
            // Ativar ou desativar modo de recuperação
            setRecoveryMode(isRecoveryMode) {
                this.recoveryMode = isRecoveryMode;
                
                // Aumentar número de simulações em modo de recuperação para precisão
                this.simulationCount = isRecoveryMode ? 3000 : 1000;
                
                // Invalidar resultados para forçar recálculo
                this.lastResults = null;
            }
            
            // Executar simulações para estimar probabilidades
            simulate() {
                // Se já temos resultados, retornar
                if (this.lastResults) return this.lastResults;
                
                const results = Array(25).fill(0);
                
                // Realizar múltiplas simulações
                for (let i = 0; i < this.simulationCount; i++) {
                    // Colocar bombas aleatoriamente, mas com viés
                    const bombPositions = this.placeBombsWithBias();
                    
                    // Incrementar contador para células sem bombas
                    for (let cell = 0; cell < 25; cell++) {
                        if (!bombPositions.includes(cell)) {
                            results[cell]++;
                        }
                    }
                }
                
                // Normalizar resultados para probabilidades
                this.lastResults = results.map(count => count / this.simulationCount);
                return this.lastResults;
            }
            
            // Coloca bombas com tendência baseada em histórico
            placeBombsWithBias() {
                const bombs = [];
                const probabilities = [...this.cellBias];
                
                // Normalizar probabilidades para soma = 1
                const sum = probabilities.reduce((a, b) => a + b, 0);
                const normalizedProbs = probabilities.map(p => p / sum);
                
                // Selecionar posições com base nas probabilidades
                while (bombs.length < this.bombCount) {
                    // Roleta russa ponderada
                    let r = Math.random();
                    let cumulative = 0;
                    let selectedPos = -1;
                    
                    for (let i = 0; i < 25; i++) {
                        cumulative += normalizedProbs[i];
                        if (r <= cumulative) {
                            selectedPos = i;
                            break;
                        }
                    }
                    
                    if (selectedPos >= 0 && !bombs.includes(selectedPos)) {
                        bombs.push(selectedPos);
                        
                        // Ajustar probabilidades para evitar concentração
                        probabilities[selectedPos] = 0;
                        const newSum = probabilities.reduce((a, b) => a + b, 0);
                        for (let i = 0; i < 25; i++) {
                            normalizedProbs[i] = newSum > 0 ? probabilities[i] / newSum : 0;
                        }
                    }
                }
                
                return bombs;
            }
            
            // Atualizar com novas informações
            update(selection, explosionPositions, wasSuccessful) {
                // Injetar conhecimento nas próximas simulações
                // Invalidar resultado anterior para forçar nova simulação
                this.lastResults = null;
                
                // Atualizar o viés de cada célula com base no resultado
                for (let i = 0; i < 25; i++) {
                    // Se a célula explodiu, aumentar sua tendência para bomba
                    if (explosionPositions.includes(i)) {
                        // No modo de recuperação, penalizar ainda mais células que explodiram
                        this.cellBias[i] *= this.recoveryMode ? 2.5 : 1.8;
                    }
                    // Se a célula foi jogada e não explodiu, diminuir sua tendência para bomba
                    else if (selection.includes(i)) {
                        this.cellBias[i] *= 0.6;
                    }
                }
                
                // Aumentar o número de simulações conforme mais dados
                this.simulationCount = Math.min(5000, this.simulationCount + 50);
            }
            
            // Obter células seguras baseado na simulação
            getSafestCells(count) {
                const safetyScores = this.simulate();
                
                // Criar array de {index, safetyScore}
                const cellsWithScores = safetyScores.map((score, index) => ({ 
                    index, 
                    safetyScore: score
                }));
                
                // Em modo de recuperação, dar peso extra para células com alta segurança
                if (this.recoveryMode) {
                    cellsWithScores.forEach(cell => {
                        // Exponenciar o score para dar mais peso a células muito seguras
                        if (cell.safetyScore > 0.8) {
                            cell.safetyScore = Math.pow(cell.safetyScore, 0.7); // Aumentar contraste
                        }
                    });
                }
                
                // Ordenar do mais seguro para menos seguro
                cellsWithScores.sort((a, b) => b.safetyScore - a.safetyScore);
                
                // Retornar os índices mais seguros
                return cellsWithScores.slice(0, count).map(cell => cell.index);
            }
            
            // Obter confiança do modelo
            getConfidence() {
                // Monte Carlo é mais confiante com mais simulações
                const baseConfidence = 40 + this.simulationCount / 100;
                
                // Em modo de recuperação, aumentar a confiança
                return Math.min(90, this.recoveryMode ? baseConfidence + 10 : baseConfidence);
            }
        }
        
        /**
         * Ensemble Predictor: Combina múltiplos modelos para previsão otimizada
         */
        class EnsemblePredictor {
            constructor() {
                this.bayesianModel = new BayesianModel();
                this.patternMemory = new PatternMemory();
                this.monteCarloSimulator = new MonteCarloSimulator();
                
                // Pesos iniciais para cada modelo
                this.weights = {
                    bayesian: 0.4,
                    pattern: 0.3,
                    monteCarlo: 0.3
                };
                
                // Histórico de desempenho de cada modelo
                this.modelPerformance = {
                    bayesian: { success: 0, failure: 0 },
                    pattern: { success: 0, failure: 0 },
                    monteCarlo: { success: 0, failure: 0 }
                };
                
                // Histórico de jogadas com dados completos
                this.gameHistory = [];
                
                // Modo de recuperação (ativado após uma perda)
                this.recoveryMode = false;
                
                // Ajustar pesos para modo de recuperação
                this.recoveryWeights = {
                    bayesian: 0.5,
                    pattern: 0.3,
                    monteCarlo: 0.2
                };
            }
            
            loadFromLocalStorage() {
                try {
                    const savedData = localStorage.getItem('minesAdvancedAI');
                    
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        
                        // Restaurar dados
                        this.weights = parsedData.weights || this.weights;
                        this.recoveryWeights = parsedData.recoveryWeights || this.recoveryWeights;
                        this.modelPerformance = parsedData.modelPerformance || this.modelPerformance;
                        this.gameHistory = parsedData.gameHistory || this.gameHistory;
                        this.recoveryMode = parsedData.recoveryMode || false;
                        
                        // Carregar modelos individuais
                        this.bayesianModel.loadFromSaved(parsedData.bayesianModel);
                        this.patternMemory.loadFromSaved(parsedData.patternMemory);
                        this.monteCarloSimulator.loadFromSaved(parsedData.monteCarloSimulator);
                        
                        // Sincronizar o modo de recuperação com todos os modelos
                        this.setRecoveryMode(this.recoveryMode);
                        
                        return true;
                    }
                } catch (error) {
                    console.error('Erro ao carregar dados do localStorage:', error);
                }
                
                return false;
            }
            
            saveToLocalStorage() {
                try {
                    const dataToSave = {
                        weights: this.weights,
                        recoveryWeights: this.recoveryWeights,
                        modelPerformance: this.modelPerformance,
                        gameHistory: this.gameHistory,
                        recoveryMode: this.recoveryMode,
                        bayesianModel: this.bayesianModel.toJSON(),
                        patternMemory: this.patternMemory.toJSON(),
                        monteCarloSimulator: this.monteCarloSimulator.toJSON(),
                        lastUpdated: new Date().toISOString()
                    };
                    
                    localStorage.setItem('minesAdvancedAI', JSON.stringify(dataToSave));
                } catch (error) {
                    console.error('Erro ao salvar dados no localStorage:', error);
                }
            }
            
            clearData() {
                // Reiniciar tudo
                this.bayesianModel = new BayesianModel();
                this.patternMemory = new PatternMemory();
                this.monteCarloSimulator = new MonteCarloSimulator();
                
                this.weights = {
                    bayesian: 0.4,
                    pattern: 0.3,
                    monteCarlo: 0.3
                };
                
                this.recoveryWeights = {
                    bayesian: 0.5,
                    pattern: 0.3,
                    monteCarlo: 0.2
                };
                
                this.modelPerformance = {
                    bayesian: { success: 0, failure: 0 },
                    pattern: { success: 0, failure: 0 },
                    monteCarlo: { success: 0, failure: 0 }
                };
                
                this.gameHistory = [];
                this.recoveryMode = false;
                
                try {
                    localStorage.removeItem('minesAdvancedAI');
                } catch (error) {
                    console.error('Erro ao limpar dados:', error);
                }
            }
            
            // Ativar ou desativar modo de recuperação
            setRecoveryMode(isRecoveryMode) {
                this.recoveryMode = isRecoveryMode;
                
                // Propagar para todos os modelos
                this.bayesianModel.setRecoveryMode(isRecoveryMode);
                this.patternMemory.setRecoveryMode(isRecoveryMode);
                this.monteCarloSimulator.setRecoveryMode(isRecoveryMode);
                
                return this.recoveryMode;
            }
            
            // Atualizar todos os modelos com novos dados
            update(selection, explosionPositions, result) {
                const wasSuccessful = result === 'success_first_try' || result === 'success_with_martingale';
                
                // Registrar no histórico
                this.gameHistory.push({
                    selection,
                    explosionPositions,
                    result,
                    recoveryMode: this.recoveryMode,
                    timestamp: Date.now()
                });
                
                // Limitar tamanho do histórico
                if (this.gameHistory.length > 100) {
                    this.gameHistory.shift();
                }
                
                // Atualizar cada modelo individual
                this.bayesianModel.update(selection, explosionPositions, wasSuccessful);
                this.patternMemory.addPattern(selection, result, explosionPositions);
                this.monteCarloSimulator.update(selection, explosionPositions, wasSuccessful);
                
                // Avaliar quais modelos teriam feito boas previsões
                this.evaluateModels(selection, explosionPositions, result);
                
                // Ajustar pesos baseado no desempenho
                this.adjustWeights();
                
                // Se perdeu, ativar modo de recuperação para próxima jogada
                // Se ganhou, desativar modo de recuperação
                if (result === 'failure') {
                    this.setRecoveryMode(true);
                } else {
                    this.setRecoveryMode(false);
                }
                
                // Salvar dados
                this.saveToLocalStorage();
            }
            
            // Avaliar o desempenho de cada modelo
            evaluateModels(selection, explosionPositions, result) {
                const wasSuccessful = result === 'success_first_try' || result === 'success_with_martingale';
                
                // Verificar se cada modelo teria recomendado a seleção atual
                const bayesianRecommendation = this.bayesianModel.getSafestCells(4);
                const patternRecommendation = this.patternMemory.getRecommendedCells(4);
                const monteCarloRecommendation = this.monteCarloSimulator.getSafestCells(4);
                
                // Calcular similaridade com a seleção atual
                const bayesianSimilarity = this.calculateOverlap(selection, bayesianRecommendation);
                const patternSimilarity = this.calculateOverlap(selection, patternRecommendation);
                const monteCarloSimilarity = this.calculateOverlap(selection, monteCarloRecommendation);
                
                // Atualizar registros de desempenho
                if (wasSuccessful) {
                    this.modelPerformance.bayesian.success += bayesianSimilarity;
                    this.modelPerformance.pattern.success += patternSimilarity;
                    this.modelPerformance.monteCarlo.success += monteCarloSimilarity;
                } else {
                    this.modelPerformance.bayesian.failure += bayesianSimilarity;
                    this.modelPerformance.pattern.failure += patternSimilarity;
                    this.modelPerformance.monteCarlo.failure += monteCarloSimilarity;
                }
            }
            
            // Calcular sobreposição entre duas seleções
            calculateOverlap(selection1, selection2) {
                return selection1.filter(cell => selection2.includes(cell)).length / 4;
            }
            
            // Ajustar pesos dos modelos baseado em desempenho
            adjustWeights() {
                // Calcular taxa de sucesso para cada modelo
                const calculateSuccessRate = (model) => {
                    const total = this.modelPerformance[model].success + this.modelPerformance[model].failure;
                    return total > 0 ? this.modelPerformance[model].success / total : 0.33;
                };
                
                const bayesianRate = calculateSuccessRate('bayesian');
                const patternRate = calculateSuccessRate('pattern');
                const monteCarloRate = calculateSuccessRate('monteCarlo');
                
                // Calcular novos pesos proporcionais às taxas de sucesso
                const total = bayesianRate + patternRate + monteCarloRate;
                
                if (total > 0) {
                    // Atualizar pesos normais
                    this.weights.bayesian = bayesianRate / total;
                    this.weights.pattern = patternRate / total;
                    this.weights.monteCarlo = monteCarloRate / total;
                    
                    // Atualizar pesos de recuperação também baseado em quão bem cada modelo
                    // se saiu em jogadas de recuperação anteriores
                    const recoveryGames = this.gameHistory.filter(g => g.recoveryMode);
                    
                    if (recoveryGames.length > 3) {
                        const successfulRecovery = recoveryGames.filter(g => 
                            g.result === 'success_first_try' || g.result === 'success_with_martingale'
                        );
                        
                        // Se temos jogadas de recuperação bem-sucedidas, ajustar pesos
                        if (successfulRecovery.length > 0) {
                            // Mais ênfase no Bayesiano para recuperação (segurança)
                            this.recoveryWeights.bayesian = 0.5;
                            this.recoveryWeights.pattern = 0.3;
                            this.recoveryWeights.monteCarlo = 0.2;
                        }
                    }
                }
                
                // Garantir que os pesos somem 1
                const normalizeWeights = (weights) => {
                    const sum = weights.bayesian + weights.pattern + weights.monteCarlo;
                    if (sum > 0) {
                        weights.bayesian /= sum;
                        weights.pattern /= sum;
                        weights.monteCarlo /= sum;
                    }
                };
                
                normalizeWeights(this.weights);
                normalizeWeights(this.recoveryWeights);
            }
            
            // Analisar padrões de explosão para identificar regiões de alto risco
            analyzeExplosionPatterns() {
                // Manter contagem das explosões para cada célula
                const explosionCounts = Array(25).fill(0);
                
                // Manter registro de células que foram jogadas mas nunca explodiram
                const playedCells = Array(25).fill(false);
                const explodedCells = Array(25).fill(false);
                
                // Analisar o histórico
                this.gameHistory.forEach(game => {
                    // Marcar células que foram jogadas
                    game.selection.forEach(cell => {
                        playedCells[cell] = true;
                    });
                    
                    // Contar explosões e marcar células que explodiram
                    game.explosionPositions.forEach(cell => {
                        explosionCounts[cell]++;
                        explodedCells[cell] = true;
                    });
                });
                
                // Identificar áreas de alto risco
                const highRiskCells = [];  // Células que explodiram múltiplas vezes
                const mediumRiskCells = []; // Células que explodiram uma vez
                const safePlayedCells = []; // Células que foram jogadas e nunca explodiram
                
                for (let i = 0; i < 25; i++) {
                    if (explosionCounts[i] >= 2) {
                        highRiskCells.push(i);
                    } else if (explosionCounts[i] === 1) {
                        mediumRiskCells.push(i);
                    } else if (playedCells[i] && !explodedCells[i]) {
                        safePlayedCells.push(i);
                    }
                }
                
                return {
                    highRiskCells,
                    mediumRiskCells,
                    safePlayedCells
                };
            }
            
            // Obter previsão combinada - OTIMIZADA PARA ALTA ASSERTIVIDADE
            predict(count = 4, previousSelections = []) {
                // Verificar se há dados suficientes para fazer previsões
                if (this.gameHistory.length < 3) {
                    // Com poucos dados, usar uma estratégia mais conservadora
                    const bombCount = this.monteCarloSimulator.bombCount || 4;
                    
                    // Forçar recálculo das simulações para casos iniciais
                    this.monteCarloSimulator.lastResults = null;
                    
                    // Para jogadas iniciais, preferir células nas bordas (geralmente mais seguras)
                    const cornerAndEdgeCells = [0, 4, 20, 24, 1, 2, 3, 5, 9, 10, 14, 15, 19, 21, 22, 23];
                    
                    // Obter células seguras com bias para bordas
                    let safeCells = this.monteCarloSimulator.getSafestCells(Math.min(12, 25 - bombCount));
                    
                    // Verificar se obtivemos células seguras 
                    if (!safeCells || !Array.isArray(safeCells) || safeCells.length === 0) {
                        console.warn("Não foi possível obter células seguras do Monte Carlo, usando fallback para bordas");
                        // Fallback: usar bordas como estratégia inicial
                        safeCells = cornerAndEdgeCells;
                    }
                    
                    console.log("Células seguras iniciais:", safeCells);
                    return this.getRandomCellsWithBias(safeCells, count, 1.2);
                }
                
                // Usar pesos diferentes dependendo do modo
                const activeWeights = this.recoveryMode ? this.recoveryWeights : this.weights;
                
                // Obter previsões de cada modelo
                const bayesianPrediction = this.bayesianModel.getSafestCells(12); // Pegar mais do que precisamos
                const patternPrediction = this.patternMemory.getRecommendedCells(12);
                const monteCarloProbs = this.monteCarloSimulator.simulate();
                const monteCarloPrediction = this.getTopCells(monteCarloProbs, 12);
                
                // Combinar previsões usando pesos
                const combinedScores = Array(25).fill(0);
                
                // Dar pontos baseados em ranking nas previsões de cada modelo
                bayesianPrediction.forEach((cell, idx) => {
                    combinedScores[cell] += activeWeights.bayesian * (12 - idx) / 12;
                });
                
                patternPrediction.forEach((cell, idx) => {
                    combinedScores[cell] += activeWeights.pattern * (12 - idx) / 12;
                });
                
                monteCarloPrediction.forEach((cell, idx) => {
                    combinedScores[cell] += activeWeights.monteCarlo * (12 - idx) / 12;
                });
                
                // Penalizar células que foram usadas recentemente
                this.applyRecentUsagePenalty(combinedScores, previousSelections);
                
                // Análise de estratégia otimizada para maximizar ganhos
            // Dar preferência para células com histórico comprovado de segurança (tanto em modo normal quanto recuperação)
            const cellSuccessRates = this.calculateCellSuccessRates();
            
            // Aplicar bônus para células com alta taxa de sucesso
            for (let i = 0; i < 25; i++) {
                const rate = cellSuccessRates[i];
                
                // Células com histórico suficiente
                if (rate.total >= 2) {
                    if (rate.successRate > 0.8) {
                        // Bônus ainda maior em modo de recuperação
                        const safetyBonus = this.recoveryMode ? 0.5 : 0.35;
                        combinedScores[i] += safetyBonus; // Bônus grande para células muito seguras
                    } 
                    else if (rate.successRate > 0.6) {
                        // Células moderadamente seguras
                        const moderateBonus = this.recoveryMode ? 0.25 : 0.15;
                        combinedScores[i] += moderateBonus;
                    }
                    else if (rate.successRate < 0.2) {
                        // Penalidade severa para células muito perigosas
                        const dangerPenalty = this.recoveryMode ? 0.7 : 0.5;
                        combinedScores[i] -= dangerPenalty;
                    }
                    else if (rate.successRate < 0.4) {
                        // Penalidade para células com baixa taxa de sucesso
                        const lowSuccessPenalty = this.recoveryMode ? 0.4 : 0.25;
                        combinedScores[i] -= lowSuccessPenalty;
                    }
                }
            }
            
            // Analisar padrões de explosão para detectar áreas de risco
            const explosionData = this.analyzeExplosionPatterns();
            
            // Aplicar penalidades para áreas com alta concentração de explosões
            for (let i = 0; i < 25; i++) {
                if (explosionData.highRiskCells.includes(i)) {
                    combinedScores[i] -= 0.6; // Forte penalidade para células com alto risco
                }
                else if (explosionData.mediumRiskCells.includes(i)) {
                    combinedScores[i] -= 0.3; // Penalidade média
                }
                // Dar bônus para células que nunca explodiram mas foram jogadas
                if (explosionData.safePlayedCells.includes(i)) {
                    combinedScores[i] += 0.2;
                }
            }
                
                // Penalizar células que explodiram recentemente
                this.applyRecentExplosionPenalty(combinedScores);
                
                // Corrigir referência a bombCount
            const bombCount = this.monteCarloSimulator.bombCount || 4;
            
            // Obter top células combinadas (agora pegamos mais células para ter mais opções)
            const topCells = this.getTopCells(combinedScores, Math.min(16, 25 - bombCount));
                
                // Análise melhorada de repetição - evitando padrões óbvios
            const isRepeated = (selection) => {
                if (previousSelections.length === 0) return false;
                
                // Focar nas seleções mais recentes
                const recentSelections = previousSelections.slice(0, 5);
                
                // Verificar sobreposição com seleções recentes
                for (let i = 0; i < recentSelections.length; i++) {
                    const overlap = this.calculateOverlap(selection, recentSelections[i]);
                    
                    // Cálculo de fator de recência melhorado - damos MUITO mais peso às jogadas mais recentes
                    // Jogada imediatamente anterior tem o dobro de importância
                    const recencyFactor = Math.exp(-0.5 * i); // Decai exponencialmente: 1, 0.61, 0.37, 0.22, 0.14...
                    
                    // Penalizar fortemente jogadas semelhantes à última jogada,
                    // especialmente se a última jogada foi uma falha
                    const lastGameWasFailure = state.consecutiveExplosions > 0;
                    
                    // Limite mais rigoroso se a última jogada foi falha
                    const overlapLimit = lastGameWasFailure ? 0.25 : 0.5;
                    
                    // Se o overlap ajustado for maior que o limite, considerar como repetição
                    if (overlap * recencyFactor >= overlapLimit * recencyFactor) {
                        return true;
                    }
                }
                
                // Verificar se a seleção forma um padrão óbvio
                if (this.formsObviousPattern(selection)) {
                    return true;
                }
                
                return false;
            };
            
            // Verificar se forma padrões óbvios (quadrado, linha, etc)
            this.formsObviousPattern = (selection) => {
                // Verificar padrão de quadrado (2x2)
                if (selection.length === 4) {
                    // Converter índices para coordenadas de grid
                    const coords = selection.map(index => ({
                        row: Math.floor(index / 5),
                        col: index % 5
                    }));
                    
                    // Verificar se as coordenadas formam um quadrado 2x2
                    const minRow = Math.min(...coords.map(c => c.row));
                    const maxRow = Math.max(...coords.map(c => c.row));
                    const minCol = Math.min(...coords.map(c => c.col));
                    const maxCol = Math.max(...coords.map(c => c.col));
                    
                    // Se width e height são ambos 1, temos um quadrado 2x2
                    if ((maxRow - minRow === 1) && (maxCol - minCol === 1)) {
                        // Verificar se temos exatamente os 4 cantos
                        const expectedCells = [
                            minRow * 5 + minCol,
                            minRow * 5 + maxCol,
                            maxRow * 5 + minCol,
                            maxRow * 5 + maxCol
                        ];
                        
                        // Se a seleção tem exatamente esses 4 pontos, é um quadrado
                        if (expectedCells.every(cell => selection.includes(cell)) &&
                            selection.every(cell => expectedCells.includes(cell))) {
                            return true;
                        }
                    }
                    
                    // Verificar se é uma linha reta (horizontal ou vertical)
                    const uniqueRows = new Set(coords.map(c => c.row)).size;
                    const uniqueCols = new Set(coords.map(c => c.col)).size;
                    
                    // Se todos os pontos compartilham a mesma linha ou coluna
                    if (uniqueRows === 1 || uniqueCols === 1) {
                        return true;
                    }
                }
                
                return false;
            };
                
                // Tentar gerar uma combinação não repetida, com mais tentativas
                let attempts = 0;
                let finalSelection = [];
                
                // Aumentar o número de tentativas para encontrar uma combinação única
                const maxAttempts = 50;
                
                while (attempts < maxAttempts && finalSelection.length < count) {
                    attempts++;
                    
                    // Usar uma abordagem mais aleatória para aumentar a variabilidade
                    // Use o modo de jogo para ajustar o viés de seleção
                    const randomnessFactor = this.recoveryMode ? 1.5 : 2.2;
                    const selectedIndices = this.getRandomCellsWithBias(topCells, count, randomnessFactor);
                    
                    // Se não é repetido ou se já tentamos muitas vezes, aceitar esta seleção
                    if (!isRepeated(selectedIndices) || attempts > maxAttempts * 0.8) {
                        finalSelection = selectedIndices;
                        break;
                    }
                }
                
                // Se ainda não encontramos uma seleção válida, criar uma mais aleatória
                if (finalSelection.length < count) {
                    console.log("Não foi possível evitar repetição após múltiplas tentativas. Gerando seleção mais aleatória.");
                    
                    // Usar um conjunto maior de células e mais aleatoriedade
                    // Corrigir referência a bombCount
                    const bombCount = this.monteCarloSimulator.bombCount || 4;
                    const extendedCellPool = this.getTopCells(combinedScores, Math.min(20, 25 - bombCount));
                    finalSelection = this.getRandomCellsWithBias(extendedCellPool, count, 3.0);
                }
                
                return finalSelection;
            }
            
            // Método otimizado para análise avançada de células usadas recentemente
            applyRecentUsagePenalty(scores, previousSelections) {
                // Obter todas as jogadas históricas
                const fullHistory = state.statsManager.getHistory();
                
                // Vamos analisar os resultados históricos das células
                const cellSuccessRates = this.calculateCellSuccessRates();
                
                // Mapa de contagem de uso para cada célula
                const cellUsageCount = Array(25).fill(0);
                
                // Mapa de sucesso para cada célula
                const cellSuccessCount = Array(25).fill(0);
                
                // Contar o uso e sucesso de cada célula
                previousSelections.forEach(selection => {
                    selection.forEach(cellIndex => {
                        cellUsageCount[cellIndex]++;
                    });
                });
                
                // Bonificar células com alta taxa de sucesso ao invés de apenas penalizá-las
                for (let i = 0; i < 25; i++) {
                    const stats = cellSuccessRates[i];
                    if (stats.total > 0) {
                        // Se uma célula tem histórico de sucesso muito alto (80%+), pode valer a pena jogá-la novamente
                        if (stats.successRate > 0.8 && stats.total >= 3) {
                            scores[i] += 0.15; // Bônus para células muito bem-sucedidas
                        }
                        // Se tem histórico regular de sucesso (60-80%), leve bônus
                        else if (stats.successRate > 0.6 && stats.total >= 2) {
                            scores[i] += 0.05;
                        }
                        // Se tem baixa taxa de sucesso ou muitas falhas, penalizar
                        else if (stats.successRate < 0.4 || stats.failure > 1) {
                            scores[i] -= 0.3;
                        }
                    }
                }
                
                // Penalizar uso excessivo (mais de 3 vezes)
                for (let i = 0; i < 25; i++) {
                    if (cellUsageCount[i] > 3) {
                        scores[i] -= 0.2; // Penalidade base para uso excessivo
                    }
                }
                
                // Análise específica das seleções recentes (últimas 3-5 jogadas)
                const recentSelections = previousSelections.slice(0, 5);
                
                // Analisar padrões recentes - evitar células de jogadas recentes se possível
                recentSelections.forEach((selection, selectionIndex) => {
                    // Calcular fator de idade: seleções muito recentes têm maior penalidade
                    const ageFactor = Math.exp(-0.3 * selectionIndex); // Decaimento exponencial (1.0, 0.74, 0.55, etc.)
                    
                    selection.forEach(cellIndex => {
                        // Penalidade que diminui com o tempo
                        const penalty = 0.25 * ageFactor;
                        scores[cellIndex] -= penalty;
                    });
                });
                
                // Verificar se tivemos jogadas perdidas consecutivas recentemente
                const hadConsecutiveLosses = (state.consecutiveExplosions > 0);
                
                if (hadConsecutiveLosses) {
                    // Se tivemos perdas consecutivas, devemos mudar drasticamente o padrão
                    // Analisar padrões das últimas 5 jogadas para evitá-los completamente
                    const recentPatterns = previousSelections.slice(0, 5);
                    
                    // Calcular "zona de perigo" - áreas do tabuleiro frequentemente usadas nas perdas
                    const dangerCellCount = Array(25).fill(0);
                    recentPatterns.forEach(selection => {
                        selection.forEach(cellIndex => {
                            // Incrementar contagem para a célula e células adjacentes
                            dangerCellCount[cellIndex]++;
                            this.getAdjacentCells(cellIndex).forEach(adjCell => {
                                dangerCellCount[adjCell] += 0.5; // Metade do peso para adjacentes
                            });
                        });
                    });
                    
                    // Penalizar fortemente as áreas de "zona de perigo"
                    for (let i = 0; i < 25; i++) {
                        if (dangerCellCount[i] > 1) {
                            scores[i] -= 0.3 * dangerCellCount[i];
                        }
                    }
                    
                    // Após perdas consecutivas, favorecer células que nunca ou raramente foram jogadas
                    // Isso incentiva uma quebra total de padrão
                    const unusedBonus = 0.2;
                    for (let i = 0; i < 25; i++) {
                        if (cellUsageCount[i] === 0) {
                            scores[i] += unusedBonus;
                        }
                    }
                }
            }
            
            // Sistema avançado para penalizar células de alto risco baseado em padrões de cassino real
            applyRecentExplosionPenalty(scores) {
                // Pegar o histórico completo, mas dar mais peso às jogadas recentes
                const allHistory = this.gameHistory;
                
                // Análise profunda do estado de jogo atual
                const hadRecentLoss = allHistory.length > 0 && allHistory[0].result === 'failure';
                const consecutiveLosses = state.consecutiveExplosions;
                
                // Fator de penalidade extremamente severo após perdas - estratégia anti-sequência
                // Especialistas em cassino aumentam drasticamente o conservadorismo após perdas
                const postLossPenaltyMultiplier = hadRecentLoss ? 5.0 : 1.0;
                
                // Em caso de perdas consecutivas, a penalidade é ainda mais severa (estratégia especialista)
                const consecutiveLossMultiplier = consecutiveLosses >= 1 ? 2.0 * consecutiveLosses : 1.0;
                
                // Combinação de multiplicadores para um efeito mais potente
                const totalPenaltyMultiplier = postLossPenaltyMultiplier * consecutiveLossMultiplier;
                
                // Mapeamento detalhado do histórico de explosões
                const explosionCounts = Array(25).fill(0);
                const explosionRecentness = Array(25).fill(0);  // Rastreia quão recentes são as explosões
                
                // Mapear detalhadamente as explosões e suas frequências
                allHistory.forEach((game, gameIndex) => {
                    game.explosionPositions.forEach(cellIndex => {
                        if (cellIndex >= 0 && cellIndex < 25) {
                            explosionCounts[cellIndex]++;
                            
                            // Quanto mais recente a explosão, maior o valor
                            const recencyValue = Math.max(explosionRecentness[cellIndex], 
                                                        Math.exp(-0.05 * gameIndex));
                            explosionRecentness[cellIndex] = recencyValue;
                        }
                    });
                });
                
                // Conhecimento especializado: o Mines tende a criar "zonas quentes" de bombas
                // Identificar áreas de maior concentração de explosões (zonas quentes)
                const heatZones = this.identifyExplosionHeatZones(explosionCounts, explosionRecentness);
                
                // Penalizar zonas quentes inteiras, não apenas células individuais
                heatZones.forEach(zone => {
                    zone.cells.forEach(cellIndex => {
                        scores[cellIndex] -= zone.intensity * 0.7 * totalPenaltyMultiplier;
                    });
                });
                
                // Iterar pelas jogadas mais recentes com atenção especial
                const recentHistory = this.gameHistory.slice(0, 15);
                recentHistory.forEach((game, gameIndex) => {
                    // Usar curva de decaimento ainda mais acentuada para as jogadas mais recentes
                    // Jogos de cassino tendem a ter "memória curta" mas intensa
                    const ageFactor = Math.exp(-0.1 * gameIndex); // Mais acentuado para maior influência recente
                    
                    // Penalizar células que explodiram com estratégia especialista
                    game.explosionPositions.forEach(cellIndex => {
                        // Penalidade extremamente severa para explosões recentes
                        const basePenalty = 0.8 * ageFactor * totalPenaltyMultiplier;
                        scores[cellIndex] -= basePenalty;
                        
                        // Formação estratégica de "zonas de exclusão" ao redor de bombas recentes
                        // Este é um padrão observado por especialistas em jogos de cassino
                        const adjacentCells = this.getAdjacentCells(cellIndex);
                        adjacentCells.forEach(adjCell => {
                            // Penalidade para células adjacentes é proporcional à proximidade e importância
                            const adjacentPenalty = 0.4 * ageFactor * totalPenaltyMultiplier;
                            scores[adjCell] -= adjacentPenalty;
                            
                            // Efeito em cascata para células na mesma linha/coluna (estratégia diagonal)
                            if (this.isInSameRowOrColumn(cellIndex, adjCell)) {
                                scores[adjCell] -= 0.2 * ageFactor * totalPenaltyMultiplier;
                            }
                        });
                        
                        // Estratégia especialista: padrão de espelhamento de bombas
                        // Bombas frequentemente aparecem em posições "espelhadas" no tabuleiro
                        const mirrorCells = this.getMirrorCells(cellIndex);
                        mirrorCells.forEach(mirrorCell => {
                            scores[mirrorCell] -= 0.3 * ageFactor;
                        });
                    });
                });
                
                // Aplicar penalidades severas para qualquer célula que já explodiu no passado
                // Princípio conservador de especialistas: "Evite cometer o mesmo erro duas vezes"
                for (let i = 0; i < 25; i++) {
                    if (explosionCounts[i] >= 1) {
                        // Penalidade extremamente crescente por frequência de explosões
                        const frequencyPenalty = 0.5 * (explosionCounts[i] * explosionCounts[i]);
                        scores[i] -= frequencyPenalty * totalPenaltyMultiplier;
                        
                        // Se temos perdas consecutivas, praticamente eliminamos células com histórico de explosão
                        if (consecutiveLosses > 0 && explosionCounts[i] >= 2) {
                            scores[i] -= 10; // Exclusão quase total desta célula
                        }
                    }
                }
                
                // Aplicar estratégia anti-cluster para evitar células em áreas suspeitas
                const suspiciousClusters = this.identifySuspiciousClusters(explosionCounts, explosionRecentness);
                suspiciousClusters.forEach(cluster => {
                    cluster.cells.forEach(cellIndex => {
                        scores[cellIndex] -= 0.4 * cluster.suspicionLevel * totalPenaltyMultiplier;
                    });
                });
            }
            
            // Identificar zonas de concentração de explosões (estratégia especialista)
            identifyExplosionHeatZones(explosionCounts, recencyValues) {
                const heatZones = [];
                
                // Estratégia para identificar zonas quentes baseadas em padrões 3x3
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        const zoneCells = [];
                        let zoneExplosions = 0;
                        let zoneRecency = 0;
                        
                        // Verificar células em uma região 3x3 com sobreposição
                        for (let r = row; r < row + 3 && r < 5; r++) {
                            for (let c = col; c < col + 3 && c < 5; c++) {
                                const cellIndex = r * 5 + c;
                                zoneCells.push(cellIndex);
                                zoneExplosions += explosionCounts[cellIndex];
                                zoneRecency += recencyValues[cellIndex];
                            }
                        }
                        
                        // Calcular intensidade da zona quente com base em explosões e recência
                        const zoneIntensity = zoneExplosions * (0.5 + 0.5 * zoneRecency / zoneCells.length);
                        
                        if (zoneIntensity > 1) {  // Limiar para considerar uma zona como "quente"
                            heatZones.push({
                                cells: zoneCells,
                                intensity: zoneIntensity
                            });
                        }
                    }
                }
                
                return heatZones;
            }
            
            // Identificar clusters suspeitos para estratégia anti-cluster
            identifySuspiciousClusters(explosionCounts, recencyValues) {
                const clusters = [];
                const cellsAnalyzed = new Set();
                
                // Buscar clusters a partir de células com histórico de explosão
                for (let i = 0; i < 25; i++) {
                    if (explosionCounts[i] > 0 && !cellsAnalyzed.has(i)) {
                        const clusterCells = [i];
                        cellsAnalyzed.add(i);
                        
                        // Expandir cluster para células adjacentes com explosões
                        this.expandCluster(i, explosionCounts, clusterCells, cellsAnalyzed);
                        
                        // Calcular nível de suspeita baseado em quantidade e recência de explosões
                        let totalRecency = 0;
                        let totalExplosions = 0;
                        
                        clusterCells.forEach(cell => {
                            totalRecency += recencyValues[cell];
                            totalExplosions += explosionCounts[cell];
                        });
                        
                        const suspicionLevel = totalExplosions * (1 + totalRecency);
                        
                        if (clusterCells.length > 1) {
                            clusters.push({
                                cells: clusterCells,
                                suspicionLevel: suspicionLevel
                            });
                        }
                    }
                }
                
                return clusters;
            }
            
            // Expandir cluster para células adjacentes (método helper)
            expandCluster(cellIndex, explosionCounts, clusterCells, cellsAnalyzed) {
                const adjacentCells = this.getAdjacentCells(cellIndex);
                
                adjacentCells.forEach(adjCell => {
                    if (!cellsAnalyzed.has(adjCell) && explosionCounts[adjCell] > 0) {
                        clusterCells.push(adjCell);
                        cellsAnalyzed.add(adjCell);
                        this.expandCluster(adjCell, explosionCounts, clusterCells, cellsAnalyzed);
                    }
                });
            }
            
            // Verifica se duas células estão na mesma linha ou coluna
            isInSameRowOrColumn(cell1, cell2) {
                const row1 = Math.floor(cell1 / 5);
                const col1 = cell1 % 5;
                const row2 = Math.floor(cell2 / 5);
                const col2 = cell2 % 5;
                
                return row1 === row2 || col1 === col2;
            }
            
            // Obter células "espelhadas" - padrão observado em jogos de cassino
            getMirrorCells(cellIndex) {
                const row = Math.floor(cellIndex / 5);
                const col = cellIndex % 5;
                const mirrorCells = [];
                
                // Espelhamento horizontal
                mirrorCells.push(row * 5 + (4 - col));
                
                // Espelhamento vertical
                mirrorCells.push((4 - row) * 5 + col);
                
                // Espelhamento diagonal
                mirrorCells.push((4 - row) * 5 + (4 - col));
                
                // Remover a própria célula se estiver incluída (célula central)
                return mirrorCells.filter(cell => cell !== cellIndex);
            }
            
            // Obter células adjacentes a uma célula
            getAdjacentCells(cellIndex) {
                const row = Math.floor(cellIndex / 5);
                const col = cellIndex % 5;
                const adjacent = [];
                
                // Verificar células nas 8 direções adjacentes
                for (let r = Math.max(0, row-1); r <= Math.min(4, row+1); r++) {
                    for (let c = Math.max(0, col-1); c <= Math.min(4, col+1); c++) {
                        const idx = r * 5 + c;
                        if (idx !== cellIndex) {
                            adjacent.push(idx);
                        }
                    }
                }
                
                return adjacent;
            }
            
            // Método para selecionar células aleatoriamente com viés para as primeiras posições
            getRandomCellsWithBias(cellPool, count, biasFactor = 1.0) {
                if (cellPool.length <= count) return [...cellPool];
                
                const selected = [];
                const availableCells = [...cellPool];
                
                while (selected.length < count && availableCells.length > 0) {
                    // Usar fórmula de aleatoriedade com viés ajustável
                    // Valores mais altos de biasFactor favorecem células no início do array
                    // Valores mais próximos de 1 tornam a seleção mais aleatória
                    const randomPower = Math.random() ** biasFactor;
                    const index = Math.floor(randomPower * availableCells.length);
                    
                    selected.push(availableCells[index]);
                    availableCells.splice(index, 1);
                }
                
                return selected;
            }
            
            // Calcular taxa de sucesso para cada célula
            calculateCellSuccessRates() {
                const cellStats = Array(25).fill().map(() => ({ success: 0, failure: 0, total: 0, successRate: 0 }));
                
                // Analisar histórico
                this.gameHistory.forEach(game => {
                    const wasSuccess = game.result === 'success_first_try' || game.result === 'success_with_martingale';
                    
                    game.selection.forEach(cell => {
                        if (game.explosionPositions.includes(cell)) {
                            cellStats[cell].failure++;
                        } else {
                            cellStats[cell].success++;
                        }
                        cellStats[cell].total++;
                    });
                });
                
                // Calcular taxas
                cellStats.forEach(stat => {
                    stat.successRate = stat.total > 0 ? stat.success / stat.total : 0;
                });
                
                return cellStats;
            }
            
            // Obter as N células com maiores valores
            getTopCells(scores, count) {
                return Array.from({length: 25}, (_, i) => i)
                    .sort((a, b) => scores[b] - scores[a])
                    .slice(0, count);
            }
            
            // Obter confiança geral do ensemble
            getConfidence() {
                // Usar pesos diferentes dependendo do modo
                const activeWeights = this.recoveryMode ? this.recoveryWeights : this.weights;
                
                // Combinar confiança de cada modelo usando os pesos
                const bayesianConfidence = this.bayesianModel.getConfidence();
                const patternConfidence = this.patternMemory.getConfidence();
                const monteCarloConfidence = this.monteCarloSimulator.getConfidence();
                
                const weightedConfidence = 
                    bayesianConfidence * activeWeights.bayesian + 
                    patternConfidence * activeWeights.pattern + 
                    monteCarloConfidence * activeWeights.monteCarlo;
                
                // Ajustar com base na quantidade de dados
                const historyBonus = Math.min(20, this.gameHistory.length * 2);
                
                // Em modo de recuperação, mostrar confiança ainda maior se temos histórico de sucesso
                if (this.recoveryMode) {
                    const recoveryGames = this.gameHistory.filter(g => g.recoveryMode);
                    const successfulRecoveries = recoveryGames.filter(g => 
                        g.result === 'success_first_try' || g.result === 'success_with_martingale'
                    ).length;
                    
                    // Se temos histórico de sucesso em recuperação, aumentar confiança
                    if (successfulRecoveries > 0) {
                        return Math.min(98, Math.max(70, Math.round(weightedConfidence + historyBonus + successfulRecoveries * 3)));
                    }
                }
                
                return Math.min(95, Math.max(20, Math.round(weightedConfidence + historyBonus)));
            }
            
            // Obter as probabilidades de segurança para todas as células
            getSafetyMap() {
                // Usar pesos diferentes dependendo do modo
                const activeWeights = this.recoveryMode ? this.recoveryWeights : this.weights;
                
                // Obter probabilidades de cada modelo
                const bayesianMap = this.bayesianModel.cellProbabilities.map(p => 1 - p);
                
                const patternScores = this.patternMemory.generateCellScores();
                
                const monteCarloMap = this.monteCarloSimulator.simulate();
                
                // Combinar usando pesos
                return bayesianMap.map((bayesianScore, idx) => {
                    return bayesianScore * activeWeights.bayesian + 
                           patternScores[idx] * activeWeights.pattern + 
                           monteCarloMap[idx] * activeWeights.monteCarlo;
                });
            }
        }

        /**
         * Sistema de Gestão de Banca com Controle de Stop Loss/Win
         */
        class BankManager {
            constructor() {
                // Valores de configuração
                this.initialBalance = 0;
                this.currentBalance = 0;
                this.stopWin = 0;
                this.stopLoss = 0;
                this.initialBet = 0;
                
                // Estado atual
                this.currentBet = 0;
                this.isRecoveryMode = false;
                this.previousLoss = 0;
                
                // Estatísticas
                this.totalWins = 0;
                this.totalLosses = 0;
                this.profitLoss = 0;
                
                // Timeout para pause
                this.pauseUntil = 0;
                this.pauseReason = '';
                
                this.loadFromLocalStorage();
            }
            
            // Configuração inicial
            setup(initialBalance, stopWin, stopLoss, betAmount) {
                this.initialBalance = parseFloat(initialBalance);
                this.currentBalance = this.initialBalance;
                this.stopWin = parseFloat(stopWin);
                this.stopLoss = parseFloat(stopLoss);
                this.initialBet = parseFloat(betAmount);
                this.currentBet = this.initialBet;
                this.isRecoveryMode = false;
                this.previousLoss = 0;
                
                this.profitLoss = 0;
                
                this.saveToLocalStorage();
                return true;
            }
            
            // Processar resultado da jogada
            processResult(result) {
                // IMPORTANTE: Garantir que estamos usando o valor correto de aposta antes de iniciar
                this.currentBet = this.getNextBet();
                
                let profit = 0;
                
                // Calcular resultado financeiro
                if (result === 'success_first_try') {
                    // Ganho: Aposta * 2.05 - Aposta = Aposta * 1.05
                    profit = this.currentBet * 1.05;
                    this.totalWins++;
                    
                    // Log para depuração
                    console.log(`Acerto de primeira. Aposta: ${this.currentBet.toFixed(2)}, Ganho: ${profit.toFixed(2)}`);
                    
                    // Reset para aposta inicial
                    this.isRecoveryMode = false;
                    this.previousLoss = 0;
                    this.currentBet = this.initialBet;
                } 
                else if (result === 'success_with_martingale') {
                    // Martingale é 2x a aposta
                    const martingaleBet = this.currentBet * 2;
                    // Ganho com martingale: (Martingale * 2.05) - (Aposta inicial + Martingale)
                    profit = martingaleBet * 2.05 - (this.currentBet + martingaleBet);
                    this.totalWins++;
                    
                    // Log para depuração
                    console.log(`Acerto com martingale. Aposta: ${this.currentBet.toFixed(2)}, Martingale: ${martingaleBet.toFixed(2)}, Ganho: ${profit.toFixed(2)}`);
                    
                    // Reset para aposta inicial
                    this.isRecoveryMode = false;
                    this.previousLoss = 0;
                    this.currentBet = this.initialBet;
                } 
                else if (result === 'failure') {
                    // Calcular o martingale (sempre 2x a aposta atual)
                    const martingaleBet = this.currentBet * 2;
                    
                    // Valor total perdido na rodada atual: aposta + martingale
                    const currentRoundLoss = this.currentBet + martingaleBet;
                    
                    // Valor negativo (perda)
                    profit = -currentRoundLoss;
                    
                    // Se já estamos em modo de recuperação e perdemos novamente
                    if (this.isRecoveryMode) {
                        // Log detalhado para depuração
                        console.log(`Perda em modo de recuperação. Aposta de recuperação: ${this.currentBet.toFixed(2)}, Martingale: ${martingaleBet.toFixed(2)}, Total perdido nesta rodada: ${currentRoundLoss.toFixed(2)}`);
                        
                        // Resetar para o modo normal
                        this.isRecoveryMode = false;
                        this.previousLoss = 0;
                        this.currentBet = this.initialBet;
                    } else {
                        // Log detalhado para depuração
                        console.log(`Primeira perda. Aposta inicial: ${this.currentBet.toFixed(2)}, Martingale: ${martingaleBet.toFixed(2)}, Total perdido: ${currentRoundLoss.toFixed(2)}`);
                        
                        // Configurar para modo de recuperação
                        // Isso garantirá que na próxima rodada, getNextBet() retornará o valor correto
                        this.previousLoss = currentRoundLoss;
                        this.isRecoveryMode = true;
                    }
                    
                    this.totalLosses++;
                }
                
                // Atualizar saldo atual e profit/loss
                this.currentBalance += profit;
                this.profitLoss = this.currentBalance - this.initialBalance;
                
                // Log adicional para verificar o status final após a rodada
                console.log(`Status após rodada: Saldo atual: ${this.currentBalance.toFixed(2)}, Lucro/Prejuízo: ${this.profitLoss.toFixed(2)}, Modo de recuperação: ${this.isRecoveryMode}, Próxima aposta: ${this.getNextBet().toFixed(2)}`);
                
                
                // Verificar se atingiu stop win/loss
                if (this.profitLoss >= this.stopWin) {
                    this.pauseReason = 'win';
                    this.pauseFor(60 * 60 * 1000); // 1 hora
                    
                    // Programar recarga automática da página
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500); // Pequeno delay para salvar os dados antes de recarregar
                    
                } else if (this.profitLoss <= -this.stopLoss) {
                    this.pauseReason = 'loss';
                    this.pauseFor(60 * 60 * 1000); // 1 hora
                    
                    // Programar recarga automática da página
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500); // Pequeno delay para salvar os dados antes de recarregar
                }
                
                this.saveToLocalStorage();
                return {
                    profit,
                    newBalance: this.currentBalance,
                    profitLoss: this.profitLoss,
                    isPaused: this.isPaused(),
                    pauseReason: this.pauseReason
                };
            }
            
            // Obter valor da próxima aposta
            getNextBet() {
                if (this.isRecoveryMode && this.previousLoss > 0) {
                    // Em modo de recuperação, a aposta é exatamente o valor total perdido anteriormente
                    return this.previousLoss;
                }
                return this.initialBet;
            }
            
            // Verificar se sistema está pausado
            isPaused() {
                return Date.now() < this.pauseUntil;
            }
            
            // Calcular tempo restante de pausa em milissegundos
            getRemainingPauseTime() {
                if (!this.isPaused()) return 0;
                return Math.max(0, this.pauseUntil - Date.now());
            }
            
            // Formatar tempo restante como mm:ss
            getFormattedPauseTime() {
                const remainingMs = this.getRemainingPauseTime();
                if (remainingMs <= 0) return '00:00';
                
                const totalSeconds = Math.floor(remainingMs / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Pausar sistema por determinado tempo
            pauseFor(milliseconds) {
                this.pauseUntil = Date.now() + milliseconds;
                this.saveToLocalStorage();
            }
            
            // Resetar pausa
            resetPause() {
                this.pauseUntil = 0;
                this.pauseReason = '';
                this.saveToLocalStorage();
            }
            
            // Resetar toda a banca para valores iniciais
            reset() {
                this.currentBalance = this.initialBalance;
                this.profitLoss = 0;
                this.currentBet = this.initialBet;
                this.isRecoveryMode = false;
                this.previousLoss = 0;
                this.pauseUntil = 0;
                this.pauseReason = '';
                this.saveToLocalStorage();
            }
            
            // Salvar no localStorage
            saveToLocalStorage() {
                try {
                    const data = {
                        initialBalance: this.initialBalance,
                        currentBalance: this.currentBalance,
                        stopWin: this.stopWin,
                        stopLoss: this.stopLoss,
                        initialBet: this.initialBet,
                        currentBet: this.currentBet,
                        isRecoveryMode: this.isRecoveryMode,
                        previousLoss: this.previousLoss,
                        totalWins: this.totalWins,
                        totalLosses: this.totalLosses,
                        profitLoss: this.profitLoss,
                        pauseUntil: this.pauseUntil,
                        pauseReason: this.pauseReason
                    };
                    localStorage.setItem('minesBankManager', JSON.stringify(data));
                } catch (error) {
                    console.error('Erro ao salvar gerenciador de banca:', error);
                }
            }
            
            // Carregar do localStorage
            loadFromLocalStorage() {
                try {
                    const savedData = localStorage.getItem('minesBankManager');
                    if (savedData) {
                        const data = JSON.parse(savedData);
                        
                        this.initialBalance = data.initialBalance || 0;
                        this.currentBalance = data.currentBalance || 0;
                        this.stopWin = data.stopWin || 0;
                        this.stopLoss = data.stopLoss || 0;
                        this.initialBet = data.initialBet || 0;
                        this.currentBet = data.currentBet || 0;
                        this.isRecoveryMode = data.isRecoveryMode || false;
                        this.previousLoss = data.previousLoss || 0;
                        this.totalWins = data.totalWins || 0;
                        this.totalLosses = data.totalLosses || 0;
                        this.profitLoss = data.profitLoss || 0;
                        this.pauseUntil = data.pauseUntil || 0;
                        this.pauseReason = data.pauseReason || '';
                        
                        return true;
                    }
                } catch (error) {
                    console.error('Erro ao carregar gerenciador de banca:', error);
                }
                return false;
            }
            
            // Limpar dados salvos
            clearData() {
                try {
                    localStorage.removeItem('minesBankManager');
                } catch (error) {
                    console.error('Erro ao limpar dados do gerenciador de banca:', error);
                }
            }
        }

        // Sistema para armazenamento e restauração de estatísticas
        class StatsManager {
            constructor() {
                this.stats = {
                    firstTrySuccesses: 0,
                    martingaleSuccesses: 0,
                    explosions: 0,
                    totalGames: 0,
                    history: []
                };
                
                this.loadStats();
            }
            
            saveStats() {
                try {
                    localStorage.setItem('minesStats', JSON.stringify(this.stats));
                } catch (error) {
                    console.error('Erro ao salvar estatísticas:', error);
                }
            }
            
            loadStats() {
                try {
                    const savedStats = localStorage.getItem('minesStats');
                    if (savedStats) {
                        this.stats = JSON.parse(savedStats);
                        return true;
                    }
                } catch (error) {
                    console.error('Erro ao carregar estatísticas:', error);
                }
                return false;
            }
            
            clearStats() {
                this.stats = {
                    firstTrySuccesses: 0,
                    martingaleSuccesses: 0,
                    explosions: 0,
                    totalGames: 0,
                    history: []
                };
                this.saveStats();
            }
            
            addGameResult(result, selection, explosionPositions = []) {
                const gameResult = {
                    timestamp: Date.now(),
                    result: result,
                    selection: [...selection],
                    explosionPositions: [...explosionPositions]
                };
                
                // Atualizar contadores
                if (result === 'success_first_try') {
                    this.stats.firstTrySuccesses++;
                } else if (result === 'success_with_martingale') {
                    this.stats.martingaleSuccesses++;
                } else if (result === 'failure') {
                    this.stats.explosions++;
                }
                
                this.stats.totalGames++;
                
                // Adicionar ao histórico
                this.stats.history.unshift(gameResult); // Adicionar no início
                
                // Limitar tamanho do histórico
                if (this.stats.history.length > 50) {
                    this.stats.history.pop(); // Remover o mais antigo
                }
                
                this.saveStats();
                return gameResult;
            }
            
            getSuccessRate() {
                const total = this.stats.totalGames;
                if (total === 0) return 0;
                
                const successes = this.stats.firstTrySuccesses + this.stats.martingaleSuccesses;
                return Math.round((successes / total) * 100);
            }
            
            getHistory() {
                return this.stats.history;
            }
        }

        // Estado do aplicativo
        const state = {
            previousSelections: [],
            consecutiveExplosions: 0,
            currentSelection: [],
            needsNewSelection: true,
            
            // Ensemble Predictor com modelos avançados
            ensemblePredictor: new EnsemblePredictor(),
            
            // Gerenciador de banca
            bankManager: new BankManager(),
            
            // Gerenciador de estatísticas
            statsManager: new StatsManager(),
            
            // Dados temporários do resultado atual
            currentResultData: {
                firstExplosion: null,
                secondExplosion: null
            }
        };

        // Elementos do DOM
        const mainContainer = document.getElementById('mainContainer');
        const setupModal = document.getElementById('setupModal');
        const setupForm = document.getElementById('setupForm');
        const resultModal = document.getElementById('resultModal');
        const timeoutModal = document.getElementById('timeoutModal');
        const firstExplosionPanel = document.getElementById('firstExplosionPanel');
        const secondExplosionPanel = document.getElementById('secondExplosionPanel');
        const confidenceBar = document.getElementById('confidenceBar');
        const confidenceText = document.getElementById('confidenceText');
        const bayesianWeight = document.getElementById('bayesianWeight');
        const patternWeight = document.getElementById('patternWeight');
        const monteCarloWeight = document.getElementById('monteCarloWeight');
        const historyList = document.getElementById('historyList');
        const emptyHistory = document.getElementById('emptyHistory');
        
        // Elementos da interface de banca
        const currentBalanceElem = document.getElementById('currentBalance');
        const profitLossElem = document.getElementById('profitLoss');
        const currentBetElem = document.getElementById('currentBet');
        const betModeElem = document.getElementById('betMode');
        const resetBankBtn = document.getElementById('resetBankBtn');

        // Criar grid do Mines (5x5)
        const gridContainer = document.querySelector('.mines-grid');
        for (let i = 0; i < 25; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center font-bold text-lg';
            cell.dataset.index = i;
            
            // Adicionar indicador de segurança (invisível inicialmente)
            const safetyIndicator = document.createElement('div');
            safetyIndicator.className = 'cell-safety-indicator';
            cell.appendChild(safetyIndicator);
            
            gridContainer.appendChild(cell);
        }

        // Renderizar o mapa de calor
        function renderHeatMap(safetyMap) {
            const cells = document.querySelectorAll('.cell');
            
            safetyMap.forEach((value, index) => {
                const cell = cells[index];
                if (!cell) return; // Pular se a célula não existir
                
                const indicator = cell.querySelector('.cell-safety-indicator');
                if (!indicator) return; // Pular se o indicador não existir
                
                // Converter valor (0-1) para cor
                const red = Math.floor(255 * (1 - value));
                const green = Math.floor(255 * value);
                const blue = 0;
                
                // Aplicar cor ao indicador (não ao cell diretamente)
                indicator.style.backgroundColor = `rgb(${red}, ${green}, ${blue})`;
                
                // Valor de segurança para debug
                cell.dataset.safety = value.toFixed(2);
            });
            
            // Verificar e atualizar elementos de interface apenas se existirem
            // Atualizar barra de confiança
            const confidence = state.ensemblePredictor.getConfidence();
            
            if (confidenceBar) {
                confidenceBar.style.width = `${confidence}%`;
                
                // Mudar cor da barra de confiança com base no valor
                if (confidence < 35) {
                    confidenceBar.className = 'bg-red-500 h-4 rounded-full transition-all duration-500';
                } else if (confidence < 65) {
                    confidenceBar.className = 'bg-yellow-500 h-4 rounded-full transition-all duration-500';
                } else {
                    confidenceBar.className = 'bg-green-500 h-4 rounded-full transition-all duration-500';
                }
            }
            
            if (confidenceText) {
                confidenceText.textContent = `${confidence}%`;
            }
            
            // Determinar qual conjunto de pesos exibir
            const weights = state.ensemblePredictor.recoveryMode ? 
                state.ensemblePredictor.recoveryWeights : 
                state.ensemblePredictor.weights;
            
            // Atualizar pesos dos modelos na interface
            if (bayesianWeight) {
                bayesianWeight.textContent = `${Math.round(weights.bayesian * 100)}%`;
            }
            
            if (patternWeight) {
                patternWeight.textContent = `${Math.round(weights.pattern * 100)}%`;
            }
            
            if (monteCarloWeight) {
                monteCarloWeight.textContent = `${Math.round(weights.monteCarlo * 100)}%`;
            }
        }
        
        // Atualizar interface de gestão de banca
        function updateBankInterface() {
            // Formatar valores monetários
            const formatCurrency = (value) => {
                return value.toLocaleString('pt-BR', {
                    style: 'currency',
                    currency: 'BRL',
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            };
            
            // Atualizar saldo e lucro/prejuízo
            currentBalanceElem.textContent = formatCurrency(state.bankManager.currentBalance);
            
            // Cor baseada em lucro ou prejuízo
            const profitLoss = state.bankManager.profitLoss;
            if (profitLoss > 0) {
                profitLossElem.textContent = formatCurrency(profitLoss);
                profitLossElem.className = 'font-semibold text-green-600 dark:text-green-400';
            } else if (profitLoss < 0) {
                profitLossElem.textContent = formatCurrency(profitLoss);
                profitLossElem.className = 'font-semibold text-red-600 dark:text-red-400';
            } else {
                profitLossElem.textContent = formatCurrency(0);
                profitLossElem.className = 'font-semibold';
            }
            
            // Próxima aposta
            const nextBet = state.bankManager.getNextBet();
            currentBetElem.textContent = formatCurrency(nextBet);
            
            // Modo de jogo
            if (state.bankManager.isRecoveryMode) {
                betModeElem.textContent = 'Recuperação';
                betModeElem.className = 'font-semibold text-red-600 dark:text-red-400';
            } else {
                betModeElem.textContent = 'Normal';
                betModeElem.className = 'font-semibold';
            }
            
            // Atualizar barras de progresso de Stop Win/Loss
            updateStopProgress();
        }
        
        // Atualizar barras de progresso para Stop Win e Stop Loss
        function updateStopProgress() {
            const stopWinValue = document.getElementById('stopWinValue');
            const stopWinPercentage = document.getElementById('stopWinPercentage');
            const stopWinProgress = document.getElementById('stopWinProgress');
            
            const stopLossValue = document.getElementById('stopLossValue');
            const stopLossPercentage = document.getElementById('stopLossPercentage');
            const stopLossProgress = document.getElementById('stopLossProgress');
            
            const formatCurrency = (value) => {
                return value.toLocaleString('pt-BR', {
                    style: 'currency',
                    currency: 'BRL',
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            };
            
            // Atualizar valores e progresso do Stop Win
            stopWinValue.textContent = formatCurrency(state.bankManager.stopWin);
            
            // Calcular a porcentagem de progresso para o stop win
            let winProgress = 0;
            if (state.bankManager.profitLoss > 0 && state.bankManager.stopWin > 0) {
                winProgress = Math.min(100, Math.round((state.bankManager.profitLoss / state.bankManager.stopWin) * 100));
            }
            
            stopWinPercentage.textContent = `${winProgress}%`;
            stopWinProgress.style.width = `${winProgress}%`;
            
            // Alterar cor conforme o progresso
            if (winProgress < 33) {
                stopWinProgress.className = 'bg-green-300 h-2.5 rounded-full transition-all duration-500';
            } else if (winProgress < 66) {
                stopWinProgress.className = 'bg-green-400 h-2.5 rounded-full transition-all duration-500';
            } else {
                stopWinProgress.className = 'bg-green-500 h-2.5 rounded-full transition-all duration-500';
            }
            
            // Atualizar valores e progresso do Stop Loss
            stopLossValue.textContent = formatCurrency(state.bankManager.stopLoss);
            
            // Calcular a porcentagem de progresso para o stop loss
            let lossProgress = 0;
            if (state.bankManager.profitLoss < 0 && state.bankManager.stopLoss > 0) {
                lossProgress = Math.min(100, Math.round((Math.abs(state.bankManager.profitLoss) / state.bankManager.stopLoss) * 100));
            }
            
            stopLossPercentage.textContent = `${lossProgress}%`;
            stopLossProgress.style.width = `${lossProgress}%`;
            
            // Alterar cor conforme o progresso
            if (lossProgress < 33) {
                stopLossProgress.className = 'bg-red-300 h-2.5 rounded-full transition-all duration-500';
            } else if (lossProgress < 66) {
                stopLossProgress.className = 'bg-red-400 h-2.5 rounded-full transition-all duration-500';
            } else {
                stopLossProgress.className = 'bg-red-500 h-2.5 rounded-full transition-all duration-500';
            }
        }

        // Função para selecionar novas células baseadas no Ensemble
        function selectNewCells() {
            if (!state.needsNewSelection) return state.currentSelection;
            
            const cells = Array.from(document.querySelectorAll('.cell'));
            
            // Limpar seleções anteriores
            cells.forEach(cell => {
                cell.classList.remove('bg-orange-500', 'text-white', 'pulse');
                cell.textContent = '';
                // Remover badges se existirem
                const badge = cell.querySelector('.ml-badge');
                if (badge) badge.remove();
            });

            // Obter recomendação do Ensemble
            const newSelection = state.ensemblePredictor.predict(4, state.previousSelections);
            
            // Renderizar o mapa de calor com probabilidades do ensemble
            renderHeatMap(state.ensemblePredictor.getSafetyMap());
            
            // Aplicar a nova seleção ao tabuleiro
            newSelection.forEach((index, i) => {
                const cell = cells[index];
                cell.classList.add('bg-orange-500', 'text-white', 'pulse');
                cell.textContent = (i + 1);
            });
            
            // Atualizar interface de banca
            updateBankInterface();
            
            // Armazenar a seleção atual
            state.currentSelection = newSelection;
            state.needsNewSelection = false;
            
            return newSelection;
        }
        
        // Atualizar estatísticas na interface
        function updateStats() {
            document.getElementById('firstTrySuccessCount').textContent = state.statsManager.stats.firstTrySuccesses;
            document.getElementById('martingaleSuccessCount').textContent = state.statsManager.stats.martingaleSuccesses;
            document.getElementById('explosionCount').textContent = state.statsManager.stats.explosions;
            document.getElementById('successRate').textContent = `${state.statsManager.getSuccessRate()}%`;
        }
        
        // Mostrar modal de resultado
        function showResultModal() {
            resultModal.classList.add('active');
            firstExplosionPanel.classList.add('hidden');
            secondExplosionPanel.classList.add('hidden');
            
            // Resetar dados temporários
            state.currentResultData = {
                firstExplosion: null,
                secondExplosion: null
            };
        }
        
        // Esconder modal de resultado
        function hideResultModal() {
            resultModal.classList.remove('active');
        }
        
        // Iniciar nova rodada após registrar resultado
        function startNewRound() {
            hideResultModal();
            state.needsNewSelection = true;
            checkAndUpdateSystemState();
            selectNewCells();
        }
        
        // Formatar data para exibição
        function formatDate(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // Renderizar histórico de jogadas
        function renderHistory() {
            const history = state.statsManager.getHistory();
            
            if (history.length === 0) {
                emptyHistory.classList.remove('hidden');
                historyList.innerHTML = '';
                return;
            }
            
            emptyHistory.classList.add('hidden');
            historyList.innerHTML = '';
            
            history.forEach((item, index) => {
                const resultText = item.result === 'success_first_try' ? 'Acerto 1ª' : 
                                  item.result === 'success_with_martingale' ? 'Acerto Gale' : 'Perda';
                const resultColor = item.result === 'success_first_try' ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' : 
                                   item.result === 'success_with_martingale' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200' : 
                                   'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200';
                
                const historyItem = document.createElement('div');
                historyItem.className = `history-item p-2 mb-2 rounded-lg bg-gray-100 dark:bg-gray-700 flex items-center justify-between ${index < 5 ? 'visible' : ''}`;
                
                // Criar delay para animação
                setTimeout(() => {
                    historyItem.classList.add('visible');
                }, index * 50);
                
                historyItem.innerHTML = `
                    <div class="flex items-center">
                        <span class="text-xs ${resultColor} px-2 py-1 rounded-full mr-2">${resultText}</span>
                        <span class="text-xs text-gray-500">${formatDate(item.timestamp)}</span>
                    </div>
                    <div class="flex">
                        ${item.selection.map((_, i) => `
                            <div class="w-5 h-5 bg-orange-500 text-white flex items-center justify-center rounded-full text-xs mr-1 ${item.explosionPositions.includes(item.selection[i]) ? 'border-2 border-red-500' : ''}">
                                ${i + 1}
                            </div>
                        `).join('')}
                    </div>
                `;
                
                historyList.appendChild(historyItem);
            });
        }
        
        // Mostrar modal de timeout
        function showTimeoutModal() {
            // Atualizar mensagem com base no motivo do timeout
            const timeoutTitle = document.getElementById('timeoutTitle');
            const timeoutMessage = document.getElementById('timeoutMessage');
            
            // Resetar área de senha sempre que o modal é mostrado
            document.getElementById('passwordInputArea').classList.add('hidden');
            document.getElementById('passwordError').classList.add('hidden');
            
            if (state.bankManager.pauseReason === 'win') {
                timeoutTitle.textContent = 'Stop Win Atingido!';
                timeoutMessage.textContent = 'Você atingiu seu objetivo de lucro! O sistema ficará pausado por 1 hora para ajudar no controle emocional.';
                timeoutTitle.className = 'text-xl font-bold mb-4 text-green-600 dark:text-green-400';
            } else if (state.bankManager.pauseReason === 'loss') {
                timeoutTitle.textContent = 'Stop Loss Atingido!';
                timeoutMessage.textContent = 'Você atingiu seu limite de perda. O sistema ficará pausado por 1 hora para ajudar no controle emocional.';
                timeoutTitle.className = 'text-xl font-bold mb-4 text-red-600 dark:text-red-400';
            } else {
                timeoutTitle.textContent = 'Sistema em Pausa';
                timeoutMessage.textContent = 'O sistema está temporariamente pausado.';
                timeoutTitle.className = 'text-xl font-bold mb-4';
            }
            
            // Exibir modal
            timeoutModal.classList.add('active');
            
            // Atualizar timer
            updateTimeoutTimer();
        }
        
        // Esconder modal de timeout
        function hideTimeoutModal() {
            timeoutModal.classList.remove('active');
        }
        
        // Atualizar timer de timeout
        function updateTimeoutTimer() {
            const timerText = document.getElementById('timerText');
            const timerCircle = document.querySelector('.timer-circle');
            
            if (state.bankManager.isPaused()) {
                const timeRemaining = state.bankManager.getRemainingPauseTime();
                const timeTotal = 60 * 60 * 1000; // 1 hora
                const progress = 100 - (timeRemaining / timeTotal * 100);
                
                timerText.textContent = state.bankManager.getFormattedPauseTime();
                timerCircle.style.setProperty('--progress', `${progress}%`);
                
                // Atualizar a cada segundo
                setTimeout(updateTimeoutTimer, 1000);
            } else {
                timerText.textContent = '00:00';
                timerCircle.style.setProperty('--progress', '100%');
                hideTimeoutModal();
                checkAndUpdateSystemState();
            }
        }
        
        // Verificar e atualizar estado do sistema (pausado/ativo)
        function checkAndUpdateSystemState() {
            // Verificar se tem configuração de banca, mas só mostrar o setup se não tiver configuração
            // prévia no localStorage (não devemos mostrar o setup apenas porque recarregamos a página)
            if (state.bankManager.initialBalance === 0 && !localStorage.getItem('minesBankManager')) {
                showSetupModal();
                return;
            }
            
            // Verificar se está em pausa
            if (state.bankManager.isPaused()) {
                // Mostrar modal de timeout
                showTimeoutModal();
                // Desativar interface principal
                mainContainer.classList.add('inactive-mode');
            } else {
                // Esconder modal de timeout
                hideTimeoutModal();
                // Ativar interface principal
                mainContainer.classList.remove('inactive-mode');
                // Atualizar interface de banca
                updateBankInterface();
            }
        }
        
        // Mostrar modal de configuração inicial
        function showSetupModal() {
            setupModal.classList.add('active');
        }

        // Ocultar modal de configuração inicial
        function hideSetupModal() {
            setupModal.classList.remove('active');
        }
        
        // Formatar inputs de moeda para padrão brasileiro (com vírgula)
        function formatCurrencyInput(input) {
            input.addEventListener('input', function(e) {
                // Remover tudo exceto números e vírgula
                let value = this.value.replace(/[^\d,]/g, '');
                
                // Substituir ponto por vírgula (caso o usuário digite ponto)
                value = value.replace(/\./g, ',');
                
                // Verificar se tem mais de uma vírgula
                const parts = value.split(',');
                if (parts.length > 2) {
                    value = parts[0] + ',' + parts.slice(1).join('');
                }
                
                // Limitar a 2 casas decimais
                if (parts.length > 1 && parts[1].length > 2) {
                    value = parts[0] + ',' + parts[1].substring(0, 2);
                }
                
                // Atualizar valor
                this.value = value;
            });
        }
        
        // Formatar todos os inputs de moeda
        function setupCurrencyInputs() {
            const moneyInputs = document.querySelectorAll('.money-input');
            moneyInputs.forEach(formatCurrencyInput);
        }
        
        // Converter valor com vírgula para formato numérico
        function parseMoneyInput(value) {
            if (!value) return 0;
            
            // Substituir vírgula por ponto para cálculos
            const numericValue = value.replace(/\./g, '').replace(',', '.');
            return parseFloat(numericValue);
        }

        // Carregar o modelo avançado de AI do localStorage
        state.ensemblePredictor.loadFromLocalStorage();
        
        // Preenche o modal de configuração com os valores atuais da banca
        function fillSetupModalWithCurrentValues() {
            const initialBalanceInput = document.getElementById('initialBalance');
            const stopWinInput = document.getElementById('stopWin');
            const stopLossInput = document.getElementById('stopLoss');
            const betAmountInput = document.getElementById('betAmount');
            
            // Formatar valores no padrão brasileiro (com vírgula decimal)
            const formatBrazilianCurrency = (value) => {
                return value.toString().replace('.', ',');
            };
            
            // Se já existe configuração, preencher com os valores atuais
            initialBalanceInput.value = formatBrazilianCurrency(state.bankManager.initialBalance);
            stopWinInput.value = formatBrazilianCurrency(state.bankManager.stopWin);
            stopLossInput.value = formatBrazilianCurrency(state.bankManager.stopLoss);
            betAmountInput.value = formatBrazilianCurrency(state.bankManager.initialBet);
            
            // Adicionar checkbox para opção de reiniciar saldo
            if (!document.getElementById('resetBalanceOption')) {
                const formDiv = document.createElement('div');
                formDiv.className = 'pt-2 pb-2';
                formDiv.innerHTML = `
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="resetBalanceOption" class="w-4 h-4 text-primary">
                        <span class="text-sm font-medium">Reiniciar saldo para o valor inicial</span>
                    </label>
                `;
                
                // Inserir antes do botão de submit
                const submitButtonContainer = setupForm.querySelector('div.pt-4');
                setupForm.insertBefore(formDiv, submitButtonContainer);
            }
            
            // Atualizar o texto do botão indicando que estamos editando a configuração
            const submitButton = setupForm.querySelector('button[type="submit"]');
            submitButton.innerHTML = 'ATUALIZAR CONFIGURAÇÃO';
        }

        // Event listeners para os botões
        setupForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const initialBalanceInput = document.getElementById('initialBalance').value;
            const stopWinInput = document.getElementById('stopWin').value;
            const stopLossInput = document.getElementById('stopLoss').value;
            const betAmountInput = document.getElementById('betAmount').value;
            const resetBalanceOption = document.getElementById('resetBalanceOption');
            const shouldResetBalance = resetBalanceOption && resetBalanceOption.checked;
            
            // Converter os valores com vírgula para valores numéricos
            const initialBalance = parseMoneyInput(initialBalanceInput);
            const stopWin = parseMoneyInput(stopWinInput);
            const stopLoss = parseMoneyInput(stopLossInput);
            const betAmount = parseMoneyInput(betAmountInput);
            
            if (initialBalance && stopWin && stopLoss && betAmount) {
                const isEditing = state.bankManager.initialBalance > 0;
                const oldBalance = state.bankManager.currentBalance;
                
                // Configurar a banca com os novos valores
                state.bankManager.setup(initialBalance, stopWin, stopLoss, betAmount);
                
                // Se estamos editando uma configuração existente e não estamos resetando o saldo
                if (isEditing && !shouldResetBalance) {
                    // Manter o saldo atual, mas atualizar o profit/loss baseado no novo saldo inicial
                    state.bankManager.currentBalance = oldBalance;
                    state.bankManager.profitLoss = state.bankManager.currentBalance - initialBalance;
                    state.bankManager.saveToLocalStorage();
                }
                // Se marcou para resetar o saldo, o setup() já fez isso (currentBalance = initialBalance)
                
                hideSetupModal();
                checkAndUpdateSystemState();
                updateBankInterface();
                
                // Mostrar mensagem de sucesso se estamos editando
                if (isEditing) {
                    alert(shouldResetBalance ? 
                        'Configuração atualizada com sucesso! Saldo reiniciado para o valor inicial.' : 
                        'Configuração atualizada com sucesso!');
                }
            }
        });
        
        document.getElementById('analyzeBtn').addEventListener('click', () => {
            if (state.bankManager.isPaused()) {
                showTimeoutModal();
                return;
            }
            
            try {
                if (state.needsNewSelection) {
                    // Selecionar novas células e garantir que a seleção foi bem-sucedida
                    const selection = selectNewCells();
                    
                    // Verificar se a seleção foi feita corretamente
                    if (!selection || selection.length === 0) {
                        console.error("Falha ao selecionar células. Tentando novamente...");
                        // Forçar uma nova seleção definindo needsNewSelection como true
                        state.needsNewSelection = true;
                        // Tentar novamente com mais diversidade
                        state.ensemblePredictor.monteCarloSimulator.lastResults = null; // Forçar recálculo
                        selectNewCells();
                    }
                } else {
                    showResultModal();
                }
            } catch (error) {
                console.error("Erro ao analisar jogada:", error);
                // Tentar recuperar do erro
                state.needsNewSelection = true;
                selectNewCells();
            }
        });
        
        // Botão de configurações (substitui o antigo resetar)
        document.getElementById('configBankBtn').addEventListener('click', () => {
            fillSetupModalWithCurrentValues();
            showSetupModal();
        });
        
        // Botão para limpar histórico
        document.getElementById('clearHistoryBtn').addEventListener('click', () => {
            if (confirm('Tem certeza que deseja limpar todo o histórico e estatísticas? Isso também reiniciará o aprendizado de IA.')) {
                // Limpar seleções atuais do tabuleiro
                const cells = Array.from(document.querySelectorAll('.cell'));
                cells.forEach(cell => {
                    cell.classList.remove('bg-orange-500', 'text-white', 'pulse');
                    cell.textContent = '';
                    
                    // Também limpar indicadores de segurança
                    const indicator = cell.querySelector('.cell-safety-indicator');
                    if (indicator) {
                        indicator.style.backgroundColor = '';
                    }
                    
                    // Remover badges se existirem
                    const badge = cell.querySelector('.ml-badge');
                    if (badge) badge.remove();
                });
                
                // Limpar os dados
                state.ensemblePredictor.clearData();
                state.statsManager.clearStats();
                state.previousSelections = [];
                
                // Garantir que o estado ficará limpo
                state.currentSelection = [];
                state.needsNewSelection = true;
                
                // Atualizar interfaces
                updateStats();
                renderHistory();
                
                // Não selecionar novas células automaticamente
                // Desta forma o tabuleiro fica limpo até o usuário clicar em "Analisar Jogada"
            }
        });
        
        // Fechar modal ao clicar fora
        resultModal.addEventListener('click', (e) => {
            if (e.target === resultModal) {
                hideResultModal();
            }
        });
        
        // Não precisamos mais deste listener já que removemos o botão de configurações
        
        // Sistema de verificação de senha para desbloqueio do stop win/loss
        document.getElementById('resetTimeBtn').addEventListener('click', () => {
            // Verificar se é um bloqueio por stop win/loss
            if (state.bankManager.pauseReason === 'win' || state.bankManager.pauseReason === 'loss') {
                // Mostrar a área de senha
                document.getElementById('passwordInputArea').classList.remove('hidden');
                // Ocultar a mensagem de erro se estiver visível
                document.getElementById('passwordError').classList.add('hidden');
                // Focar no campo de senha
                document.getElementById('unlockPassword').focus();
            } else {
                // Se não for stop win/loss, apenas confirma normalmente
                if (confirm('Tem certeza que deseja remover o tempo de pausa? Recomendamos respeitar os tempos de pausa para melhor controle emocional.')) {
                    state.bankManager.resetPause();
                    hideTimeoutModal();
                    checkAndUpdateSystemState();
                }
            }
        });
        
        // Verificar senha para desbloqueio
        document.getElementById('confirmUnlockBtn').addEventListener('click', () => {
            const passwordInput = document.getElementById('unlockPassword');
            const errorMsg = document.getElementById('passwordError');
            
            // Senha fixa para reiniciar o bloqueio de stop win/loss: "162702"
            const stopResetPassword = "162702";
            
            // Verificar se a senha é a correta
            if (passwordInput.value === stopResetPassword) {
                // Senha correta - desbloquear
                state.bankManager.resetPause();
                hideTimeoutModal();
                checkAndUpdateSystemState();
                
                // Limpar o campo de senha
                passwordInput.value = '';
                // Esconder a área de senha
                document.getElementById('passwordInputArea').classList.add('hidden');
            } else {
                // Senha incorreta - mostrar erro
                errorMsg.classList.remove('hidden');
                // Limpar o campo de senha
                passwordInput.value = '';
            }
        });
        
        // Permitir pressionar Enter no campo de senha
        document.getElementById('unlockPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('confirmUnlockBtn').click();
            }
        });
        
        // Botão de encerrar sessão
        document.getElementById('endSessionBtn').addEventListener('click', async () => {
            // Inicializar sistema de autenticação e carregar dados
            const authSystem = new AuthSystem();
            
            // Carregar os dados dos usuários de forma assíncrona
            await authSystem.loadUserData();
            
            // Obter informações do usuário atual do localStorage
            let userEmail = "";
            let userPassword = "";
            
            try {
                if (localStorage.getItem('minesUser')) {
                    const userData = JSON.parse(localStorage.getItem('minesUser'));
                    userEmail = userData.email;
                    
                    // Verificar se é o usuário de teste
                    if (userEmail === "teste@teste.com") {
                        userPassword = "123456";
                        console.log("Usando senha do usuário de teste");
                    } 
                    // Buscar a senha do usuário nos dados carregados
                    else if (authSystem.userData && authSystem.userData.length > 0) {
                        const user = authSystem.userData.find(u => u.email.toLowerCase() === userEmail.toLowerCase());
                        if (user) {
                            userPassword = user.senha;
                            console.log("Senha recuperada para o usuário:", userEmail);
                        } else {
                            console.warn("Usuário não encontrado na planilha:", userEmail);
                        }
                    }
                }
            } catch (error) {
                console.error("Erro ao obter senha do usuário:", error);
            }

            // Criar e mostrar modal de senha
            if (!document.getElementById('endSessionModal')) {
                const endSessionModal = document.createElement('div');
                endSessionModal.id = 'endSessionModal';
                endSessionModal.className = 'modal-overlay';
                endSessionModal.innerHTML = `
                    <div class="modal-content dark:bg-gray-800">
                        <div class="flex flex-col items-center text-center">
                            <div class="text-xl font-bold mb-4 text-red-600 dark:text-red-400">
                                <i class="fas fa-sign-out-alt mr-2"></i>Encerrar Sessão
                            </div>
                            
                            <div class="mb-6 p-4 bg-red-50 dark:bg-red-900/30 rounded-lg border-l-4 border-red-500">
                                <p class="text-red-700 dark:text-red-300">Atenção: esta ação irá limpar todos os dados e configurações do aplicativo.</p>
                            </div>
                            
                            <div class="w-full mb-4">
                                <div class="text-sm mb-2">Digite sua senha de login para confirmar:</div>
                                <div class="relative">
                                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                        <i class="fas fa-lock text-gray-400"></i>
                                    </div>
                                    <input type="password" inputmode="numeric" pattern="[0-9]*" id="endSessionPassword" class="w-full pl-10 pr-3 py-3 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-red-500 focus:border-red-500 dark:bg-gray-700 dark:text-white text-base" placeholder="Digite sua senha">
                                    <button id="confirmEndSessionBtn" class="absolute inset-y-0 right-0 px-4 py-2 bg-red-600 text-white font-bold rounded-r-md hover:bg-red-700 transition-all duration-300">
                                        <i class="fas fa-check"></i>
                                    </button>
                                </div>
                                <div id="endSessionPasswordError" class="text-sm text-red-500 mt-2 hidden">
                                    <i class="fas fa-exclamation-circle mr-1"></i>Senha incorreta!
                                </div>
                            </div>
                            
                            <button id="cancelEndSessionBtn" class="w-full py-3 bg-gray-300 dark:bg-gray-700 text-gray-800 dark:text-gray-200 font-bold rounded-lg hover:bg-gray-400 dark:hover:bg-gray-600 transition-all duration-300">
                                CANCELAR
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(endSessionModal);
                
                // Adicionar listeners para o modal de encerrar sessão
                document.getElementById('confirmEndSessionBtn').addEventListener('click', async () => {
                    const passwordInput = document.getElementById('endSessionPassword');
                    const errorMsg = document.getElementById('endSessionPasswordError');
                    
                    // Verificar se a senha é a mesma do login do usuário
                    const inputPassword = passwordInput.value;
                    
                    // Se não temos a senha do usuário, tentar obter novamente
                    let finalPassword = userPassword;
                    if (!finalPassword) {
                        try {
                            // Verificar se temos um usuário logado
                            const savedUserData = localStorage.getItem('minesUser');
                            if (savedUserData) {
                                const userData = JSON.parse(savedUserData);
                                
                                // Tentar carregar novamente os dados da planilha para garantir
                                const authSystem = new AuthSystem();
                                await authSystem.loadUserData();
                                
                                // Para usuário de teste
                                if (userData.email === "teste@teste.com") {
                                    finalPassword = "123456";
                                    console.log("Usando senha de teste");
                                } 
                                // Para usuários reais, buscar na planilha
                                else if (authSystem.userData && authSystem.userData.length > 0) {
                                    const user = authSystem.userData.find(u => 
                                        u.email.toLowerCase() === userData.email.toLowerCase());
                                    
                                    if (user) {
                                        finalPassword = user.senha;
                                        console.log("Senha encontrada na planilha");
                                    } else {
                                        console.warn("Usuário não encontrado na planilha:", userData.email);
                                    }
                                }
                            }
                        } catch (error) {
                            console.error("Erro ao tentar recuperar senha novamente:", error);
                        }
                    }
                    
                    console.log("Senha informada:", inputPassword);
                    console.log("Senha esperada:", finalPassword);
                    
                    // Agora verifica apenas se a senha corresponde à senha do usuário
                    if (finalPassword && inputPassword === finalPassword) {
                        // Senha correta - limpar todos os dados com animação
                        try {
                            // Mostrar feedback visual de processamento
                            const confirmBtn = document.getElementById('confirmEndSessionBtn');
                            confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                            confirmBtn.disabled = true;
                            
                            // Limpar dados de IA
                            state.ensemblePredictor.clearData();
                            
                            // Limpar dados de estatísticas
                            state.statsManager.clearStats();
                            
                            // Limpar dados da banca
                            state.bankManager.clearData();
                            
                            // Limpar quaisquer outros dados no localStorage
                            localStorage.clear();
                            
                            // Feedback de sucesso antes de recarregar
                            const modalContent = document.querySelector('#endSessionModal .modal-content');
                            modalContent.innerHTML = `
                                <div class="py-8 flex flex-col items-center">
                                    <div class="text-green-500 text-5xl mb-4"><i class="fas fa-check-circle"></i></div>
                                    <h3 class="text-xl font-bold mb-2">Sessão encerrada com sucesso!</h3>
                                    <p class="text-gray-600 dark:text-gray-400 mb-4">Redirecionando para a tela inicial...</p>
                                    <div class="w-16 h-1 bg-gray-200 dark:bg-gray-700 rounded">
                                        <div class="bg-green-500 h-1 rounded animate-[progress_1.5s_ease-in-out]" style="animation: progress 1.5s ease-in-out forwards;"></div>
                                    </div>
                                </div>
                                <style>
                                    @keyframes progress {
                                        from { width: 0; }
                                        to { width: 100%; }
                                    }
                                </style>
                            `;
                            
                            // Recarregar a página após a animação
                            setTimeout(() => {
                                window.location.reload();
                            }, 1500);
                            
                        } catch (error) {
                            console.error("Erro ao limpar dados:", error);
                            alert("Ocorreu um erro ao encerrar a sessão. Por favor, tente novamente.");
                        }
                    } else {
                        // Senha incorreta - mostrar erro com efeito de tremor
                        errorMsg.classList.remove('hidden');
                        const passwordField = document.getElementById('endSessionPassword');
                        
                        // Efeito de tremor para feedback visual
                        passwordField.classList.add('animate-[shake_0.5s_ease-in-out]');
                        passwordField.style.animation = 'shake 0.5s ease-in-out';
                        passwordField.style.borderColor = '#ef4444';
                        
                        // Limpar a senha e a animação após um momento
                        passwordInput.value = '';
                        setTimeout(() => {
                            passwordField.style.animation = '';
                            passwordField.focus();
                        }, 500);
                    }
                });
                
                // Adicionar estilos de animação para o efeito de tremor
                const styleElement = document.createElement('style');
                styleElement.textContent = `
                    @keyframes shake {
                        0%, 100% { transform: translateX(0); }
                        20%, 60% { transform: translateX(-5px); }
                        40%, 80% { transform: translateX(5px); }
                    }
                `;
                document.head.appendChild(styleElement);
                
                // Permitir Enter no campo de senha
                document.getElementById('endSessionPassword').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('confirmEndSessionBtn').click();
                    }
                });
                
                // Botão de cancelar
                document.getElementById('cancelEndSessionBtn').addEventListener('click', () => {
                    document.getElementById('endSessionModal').classList.remove('active');
                });
                
                // Clique fora do modal para fechar
                document.getElementById('endSessionModal').addEventListener('click', (e) => {
                    if (e.target === document.getElementById('endSessionModal')) {
                        document.getElementById('endSessionModal').classList.remove('active');
                    }
                });
            }
            
            // Mostrar o modal
            document.getElementById('endSessionModal').classList.add('active');
            
            // Focar no campo de senha e garantir que o teclado numérico seja aberto em dispositivos móveis
            setTimeout(() => {
                const passwordInput = document.getElementById('endSessionPassword');
                passwordInput.value = ''; // Limpar o campo
                document.getElementById('endSessionPasswordError').classList.add('hidden'); // Esconder erro
                passwordInput.focus();
            }, 100);
        });
        
        // Listeners para os botões de resultado
        document.getElementById('wonFirstTryBtn').addEventListener('click', () => {
            // Registra sucesso de primeira
            if (state.currentSelection.length > 0) {
                state.previousSelections.push([...state.currentSelection]);
                state.consecutiveExplosions = 0;
                
                // Registrar resultado nas estatísticas
                state.statsManager.addGameResult('success_first_try', state.currentSelection);
                
                // Atualizar ensemble predictor
                state.ensemblePredictor.update(
                    state.currentSelection,
                    [],
                    'success_first_try'
                );
                
                // Processar resultado financeiro
                state.bankManager.processResult('success_first_try');
                
                updateStats();
                renderHistory();
            }
            
            startNewRound();
        });
        
        document.getElementById('wonMartingaleBtn').addEventListener('click', () => {
            // Mostra painel para indicar qual quadrado explodiu na primeira tentativa
            firstExplosionPanel.classList.remove('hidden');
            secondExplosionPanel.classList.add('hidden');
            
            // Marcar este botão para referência
            document.getElementById('wonMartingaleBtn').dataset.active = 'true';
            document.getElementById('lostBtn').dataset.active = 'false';
        });
        
        document.getElementById('lostBtn').addEventListener('click', () => {
            // Mostra painel para indicar qual quadrado explodiu na primeira tentativa
            firstExplosionPanel.classList.remove('hidden');
            secondExplosionPanel.classList.add('hidden');
            
            // Marcar este botão para referência
            document.getElementById('lostBtn').dataset.active = 'true';
            document.getElementById('wonMartingaleBtn').dataset.active = 'false';
        });
        
        // Adicionar listeners para os botões de posição de explosão (primeira tentativa)
        document.querySelectorAll('.explosion-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const position = parseInt(btn.dataset.position);
                state.currentResultData.firstExplosion = position;
                
                // Verificar qual botão foi clicado anteriormente
                const lostBtnWasClicked = document.getElementById('lostBtn').dataset.active === 'true';
                const martingaleBtnWasClicked = document.getElementById('wonMartingaleBtn').dataset.active === 'true';
                
                if (lostBtnWasClicked) {
                    // Se clicou em "Perdeu com martingale", mostrar o segundo painel
                    secondExplosionPanel.classList.remove('hidden');
                } else if (martingaleBtnWasClicked) {
                    // Se clicou em "Acertou com martingale", registrar sucesso
                    if (state.currentSelection.length > 0) {
                        state.previousSelections.push([...state.currentSelection]);
                        state.consecutiveExplosions = 0;
                        
                        // Identificar o índice real da célula que explodiu
                        const explosionCellIndex = state.currentSelection[position - 1];
                        
                        // Registrar resultado nas estatísticas
                        state.statsManager.addGameResult(
                            'success_with_martingale',
                            state.currentSelection,
                            [explosionCellIndex]
                        );
                        
                        // Atualizar ensemble predictor
                        state.ensemblePredictor.update(
                            state.currentSelection,
                            [explosionCellIndex],
                            'success_with_martingale'
                        );
                        
                        // Processar resultado financeiro
                        state.bankManager.processResult('success_with_martingale');
                        
                        updateStats();
                        renderHistory();
                    }
                    
                    startNewRound();
                }
            });
        });
        
        // Adicionar listeners para os botões de posição de explosão (segunda tentativa)
        document.querySelectorAll('.explosion-btn-second').forEach(btn => {
            btn.addEventListener('click', () => {
                const position = parseInt(btn.dataset.position);
                state.currentResultData.secondExplosion = position;
                
                // Registrar perda
                if (state.currentSelection.length > 0) {
                    state.previousSelections.push([...state.currentSelection]);
                    state.consecutiveExplosions++;
                    
                    // Identificar os índices reais das células que explodiram
                    const firstExplosionCellIndex = state.currentSelection[state.currentResultData.firstExplosion - 1];
                    const secondExplosionCellIndex = state.currentSelection[position - 1];
                    
                    // Registrar resultado nas estatísticas
                    state.statsManager.addGameResult(
                        'failure',
                        state.currentSelection,
                        [firstExplosionCellIndex, secondExplosionCellIndex]
                    );
                    
                    // Atualizar ensemble predictor
                    state.ensemblePredictor.update(
                        state.currentSelection,
                        [firstExplosionCellIndex, secondExplosionCellIndex],
                        'failure'
                    );
                    
                    // Processar resultado financeiro
                    state.bankManager.processResult('failure');
                    
                    updateStats();
                    renderHistory();
                }
                
                startNewRound();
            });
        });
        
        /**
         * Sistema de autenticação com Google Sheets
         */
        class AuthSystem {
            constructor() {
                this.apiKey = 'AIzaSyCauTL_CvDiEta8NHWd1vVne-5FHBskPv4';
                this.spreadsheetId = '1RLyYB6laecNnwaOmKuj6d_kcamKzP1_FIJ4AYC_BOnk';
                this.range = 'P%C3%A1gina1!A:D'; // Colunas: NOME, EMAIL, SENHA, STATUS DA COMPRA
                this.userData = null;
                this.currentUser = null;
            }
            
            // Carregar dados da planilha
            async loadUserData() {
                try {
                    // Use o formato de exportação pública para evitar problemas de CORS
                    const url = `https://sheets.googleapis.com/v4/spreadsheets/${this.spreadsheetId}/values/${this.range}?key=${this.apiKey}`;
                    
                    console.log("Tentando carregar dados da URL:", url);
                    
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        console.error('Erro ao carregar dados da planilha:', response.status, response.statusText);
                        
                        // Tentar carregar usuário de teste para debug
                        console.log("Usando dados de teste para debug");
                        this.userData = [
                            {
                                nome: "Usuário Teste",
                                email: "teste@teste.com",
                                senha: "123456",
                                status: "Pago"
                            }
                        ];
                        return this.userData;
                    }
                    
                    const data = await response.json();
                    console.log("Dados recebidos:", data);
                    
                    if (!data.values || data.values.length <= 1) {
                        console.error('Dados inválidos ou vazios na planilha');
                        
                        // Usar dados de teste como fallback
                        this.userData = [
                            {
                                nome: "Usuário Teste",
                                email: "teste@teste.com",
                                senha: "123456",
                                status: "Pago"
                            }
                        ];
                        return this.userData;
                    }
                    
                    // Processar dados - pular a primeira linha (cabeçalho)
                    this.userData = data.values.slice(1).map(row => ({
                        nome: row[0] || '',
                        email: row[1] || '',
                        senha: row[2] || '',
                        status: row[3] || ''
                    }));
                    
                    console.log("Usuários carregados:", this.userData.length);
                    return this.userData;
                } catch (error) {
                    console.error('Erro ao carregar dados:', error);
                    
                    // Adicionar usuário de teste para garantir acesso em caso de falha
                    this.userData = [
                        {
                            nome: "Usuário Teste",
                            email: "teste@teste.com",
                            senha: "123456",
                            status: "Pago"
                        }
                    ];
                    return this.userData;
                }
            }
            
            // Verificar credenciais do usuário
            verifyCredentials(email, senha) {
                if (!this.userData) {
                    return { success: false, message: 'Erro ao carregar dados de usuário' };
                }
                
                console.log("Verificando credenciais para:", email);
                console.log("Dados disponíveis para verificação:", this.userData);
                
                // Usuario de teste para debug - sempre permite acesso
                if (email === "teste@teste.com" && senha === "123456") {
                    console.log("Usando credenciais de teste");
                    const testUser = {
                        nome: "Usuário Teste",
                        email: "teste@teste.com",
                        senha: "123456",
                        status: "Pago"
                    };
                    
                    this.currentUser = testUser;
                    this.saveUserToLocalStorage(testUser);
                    return { success: true, user: testUser };
                }
                
                const user = this.userData.find(u => u.email.toLowerCase() === email.toLowerCase() && u.senha === senha);
                
                if (!user) {
                    console.log("Usuário não encontrado ou senha incorreta");
                    return { success: false, message: 'Email ou senha incorretos' };
                }
                
                // Verificar explicitamente se o status é "Pago" - comparação case insensitive
                if (user.status.toLowerCase() !== 'pago') {
                    console.log("Usuário encontrado mas status não é 'Pago':", user.status);
                    return { success: false, message: 'Acesso não liberado. Status da compra: ' + user.status };
                }
                
                // Login bem-sucedido
                console.log("Login bem-sucedido para:", user.nome);
                this.currentUser = user;
                this.saveUserToLocalStorage(user);
                
                return { success: true, user };
            }
            
            // Salvar dados do usuário no localStorage
            saveUserToLocalStorage(user) {
                localStorage.setItem('minesUser', JSON.stringify({
                    email: user.email,
                    nome: user.nome,
                    timestamp: Date.now()
                }));
            }
            
            // Verificar se já existe um login válido
            checkSavedLogin() {
                try {
                    const savedLogin = localStorage.getItem('minesUser');
                    if (!savedLogin) return null;
                    
                    const login = JSON.parse(savedLogin);
                    const now = Date.now();
                    const loginTime = login.timestamp || 0;
                    
                    // Login expira em 7 dias
                    if (now - loginTime > 7 * 24 * 60 * 60 * 1000) {
                        localStorage.removeItem('minesUser');
                        return null;
                    }
                    
                    this.currentUser = login;
                    return login;
                } catch (error) {
                    console.error('Erro ao verificar login salvo:', error);
                    return null;
                }
            }
            
            // Logout
            logout() {
                this.currentUser = null;
                localStorage.removeItem('minesUser');
            }
        }
        
        // Função para preparar o sistema de login sem exibi-lo
        async function prepareLoginSystem() {
            const loginForm = document.getElementById('loginForm');
            const loginMessage = document.getElementById('loginMessage');
            const loginLoading = document.getElementById('loginLoading');
            const loginModal = document.getElementById('loginModal');
            const mainContainer = document.getElementById('mainContainer');
            
            const authSystem = new AuthSystem();
            
            // Não exibir mensagem de teste por padrão
            loginMessage.classList.add('hidden');
            
            // Não verificamos login salvo aqui, isso já é feito no carregamento inicial
            
            // Carregar dados dos usuários em background
            try {
                // Pré-carregar dados dos usuários em segundo plano
                authSystem.loadUserData().then(userData => {
                    console.log("Dados de usuários carregados em segundo plano");
                    if (!userData) {
                        console.warn("Falha ao carregar dados de usuários");
                    }
                });
            } catch (error) {
                console.error("Erro ao carregar dados:", error);
            }
            
            // Evento de submit do formulário
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = document.getElementById('loginEmail').value.trim();
                const senha = document.getElementById('loginPassword').value.trim();
                
                if (!email || !senha) {
                    showLoginMessage('Por favor, preencha todos os campos', true);
                    return;
                }
                
                // Verificar credenciais
                showLoginLoading(true);
                const result = authSystem.verifyCredentials(email, senha);
                showLoginLoading(false);
                
                if (!result.success) {
                    showLoginMessage(result.message, true);
                    return;
                }
                
                // Login bem-sucedido - fechar modal de login
                loginModal.classList.remove('active');
                loginModal.style.display = 'none';
                
                // Ocultar tela inicial
                const initialScreen = document.getElementById('initialScreen');
                initialScreen.classList.remove('active');
                initialScreen.style.display = 'none';
                
                // Mostrar app
                mainContainer.style.display = 'block';
                
                // Inicializar o app principal
                initMainApp();
            });
            
            // Funções auxiliares para interface de login
            function showLoginMessage(message, isError) {
                loginMessage.innerHTML = `<p class="text-sm ${isError ? 'text-red-500 dark:text-red-400' : 'text-gray-600 dark:text-gray-300'}">${message}</p>`;
                loginMessage.classList.remove('hidden');
            }
            
            function showLoginLoading(show) {
                if (show) {
                    loginLoading.classList.remove('hidden');
                    document.getElementById('loginButton').disabled = true;
                } else {
                    loginLoading.classList.add('hidden');
                    document.getElementById('loginButton').disabled = false;
                }
            }
        }
        
        // Função para inicializar o app principal após login bem-sucedido
        function initMainApp() {
            // Inicializar elementos
            setupCurrencyInputs();
            updateStats();
            renderHistory();
            
            // Forçar a desativação do setup modal se temos configuração salva
            if (localStorage.getItem('minesBankManager')) {
                // Garantir que o modal está escondido
                setupModal.classList.remove('active');
            }
            
            // Verificar o estado do sistema
            checkAndUpdateSystemState();
            
            // NÃO selecionar novas células automaticamente ao carregar a página
            // Apenas preparar o estado para quando o botão Analisar for clicado
            if (!state.bankManager.isPaused()) {
                // Apenas configurar para que esteja pronto quando o botão for clicado
                state.needsNewSelection = true;
                
                // Atualizar a interface da banca sem selecionar células
                updateBankInterface();
                
                console.log("Página carregada, aguardando o usuário clicar em 'Analisar Jogada'");
            }
            
            // Aplicar um mapa de calor inicial se possível
            if (state.ensemblePredictor.gameHistory.length > 0) {
                renderHeatMap(state.ensemblePredictor.getSafetyMap());
            }
        }
        
        // Exibir o nome do usuário na mensagem de boas-vindas
        function showUserWelcome() {
            try {
                const welcomeMessage = document.getElementById('welcomeMessage');
                const userNameDisplay = document.getElementById('userNameDisplay');
                
                // Obter informações do usuário do localStorage
                const savedUserData = localStorage.getItem('minesUser');
                
                if (savedUserData) {
                    const userData = JSON.parse(savedUserData);
                    
                    if (userData && userData.nome) {
                        // Exibir o nome do usuário
                        userNameDisplay.textContent = userData.nome;
                        // Mostrar a mensagem de boas-vindas
                        welcomeMessage.classList.remove('hidden');
                        
                        // Adicionar efeito de animação de entrada
                        welcomeMessage.style.animationDelay = '0.3s';
                    }
                }
            } catch (error) {
                console.error('Erro ao mostrar mensagem de boas-vindas:', error);
            }
        }
        
        // Inicializar a tela de boas-vindas e login
        document.addEventListener('DOMContentLoaded', () => {
            const initialScreen = document.getElementById('initialScreen');
            const openLoginBtn = document.getElementById('openLoginBtn');
            const closeLoginBtn = document.getElementById('closeLoginBtn');
            const loginModal = document.getElementById('loginModal');
            const mainContainer = document.getElementById('mainContainer');
            
            // Garantir que inicialmente apenas a tela de boas-vindas esteja visível
            initialScreen.style.display = 'block';
            loginModal.style.display = 'none';
            mainContainer.style.display = 'none';
            
            // Remover classes active para garantir estado inicial correto
            initialScreen.classList.add('active');
            loginModal.classList.remove('active');
            
            // Verificar se já tem login salvo
            const authSystem = new AuthSystem();
            const savedLogin = authSystem.checkSavedLogin();
            
            if (savedLogin) {
                // Já tem login válido, pular direto para o app
                console.log('Login válido encontrado, mostrando aplicativo');
                initialScreen.style.display = 'none';
                initialScreen.classList.remove('active');
                mainContainer.style.display = 'block';
                initMainApp();
                return;
            }
            
            // Preparar o sistema de login (mas NÃO mostrar o modal ainda)
            prepareLoginSystem();
            
            // Botão para abrir o modal de login
            openLoginBtn.addEventListener('click', () => {
                console.log('Botão LOGIN clicado, abrindo modal de login');
                loginModal.style.display = 'flex';
                loginModal.classList.add('active');
            });
            
            // Botão para fechar o modal de login
            closeLoginBtn.addEventListener('click', () => {
                console.log('Fechando modal de login');
                loginModal.classList.remove('active');
                setTimeout(() => {
                    loginModal.style.display = 'none';
                }, 300); // Aguardar a animação terminar
            });
        });
        
        // Função para mostrar a saudação personalizada no cabeçalho
        function updateUserGreeting() {
            try {
                const userGreeting = document.getElementById('userGreeting');
                const userFirstName = document.getElementById('userFirstName');
                
                // Obter informações do usuário do localStorage
                const savedUserData = localStorage.getItem('minesUser');
                
                if (savedUserData) {
                    const userData = JSON.parse(savedUserData);
                    
                    if (userData && userData.nome) {
                        // Extrair apenas o primeiro nome
                        const firstName = userData.nome.split(' ')[0];
                        
                        // Exibir o primeiro nome do usuário
                        userFirstName.textContent = firstName;
                        
                        // Mostrar a saudação
                        userGreeting.classList.remove('hidden');
                    }
                }
            } catch (error) {
                console.error('Erro ao mostrar saudação personalizada:', error);
            }
        }
        
        // Modificar a função initMainApp para incluir a chamada da nova função
        const originalInitMainApp = initMainApp;
        initMainApp = function() {
            // Chamar a função original
            originalInitMainApp();
            
            // Atualizar saudação personalizada no cabeçalho
            updateUserGreeting();
        };
    </script>

    <!-- Registro do Service Worker -->
    <script>
        // Registrar o Service Worker quando a página for carregada
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                .then(registration => {
                    console.log('Service Worker registrado com sucesso:', registration.scope);
                })
                .catch(error => {
                    console.error('Falha ao registrar o Service Worker:', error);
                });
            });
        }
    </script>
</body>
</html>
